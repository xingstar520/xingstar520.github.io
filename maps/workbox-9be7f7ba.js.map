{"version":3,"file":"../workbox-9be7f7ba.js","names":["define","exports","self","_","e","logger","globalThis","__WB_DISABLE_DEV_LOGS","inGroup","methodToColorMap","debug","log","warn","error","groupCollapsed","groupEnd","print","method","args","test","navigator","userAgent","console","logPrefix","join","api","loggerMethods","Object","keys","key","messages$1","paramName","validValueDescription","value","Error","JSON","stringify","moduleName","className","funcName","expectedType","expectedClassName","isReturnValueProblem","classNameStr","expectedMethod","entry","firstEntry","secondEntry","thrownErrorMessage","cacheNameId","name","methodName","expectedClass","normalizedRangeHeader","size","start","end","url","message","status","cacheName","origin","type","messageGenerator","code","details","WorkboxError","constructor","errorCode","super","this","finalAssertExports","object","Array","isArray","validValues","includes","validMethods","normalizeHandler","handler","handle","Route","match","setCatchHandler","catchHandler","RegExpRoute","regExp","RegExp","result","exec","href","location","index","slice","toString","getFriendlyURL","URL","String","replace","Router","_routes","Map","_defaultHandlerMap","routes","addFetchListener","addEventListener","event","request","responsePromise","handleRequest","respondWith","addCacheListener","data","payload","urlsToCache","requestPromises","Promise","all","map","Request","waitUntil","ports","then","postMessage","protocol","startsWith","sameOrigin","params","route","findMatchingRoute","debugMessages","push","has","get","forEach","msg","err","reject","_catchHandler","catch","async","catchErr","matchResult","length","undefined","setDefaultHandler","set","registerRoute","unregisterRoute","routeIndex","indexOf","splice","defaultRouter","getOrCreateDefaultRouter","capture","captureUrl","valueToCheck","pathname","wildcards","_cacheNameDetails","googleAnalytics","precache","prefix","runtime","suffix","registration","scope","_createCacheName","filter","cacheNames","userCacheName","dontWaitFor","promise","quotaErrorCallbacks","Set","_extends","assign","bind","n","arguments","t","r","hasOwnProperty","call","apply","idbProxyableTypes","cursorAdvanceMethods","cursorRequestMap","WeakMap","transactionDoneMap","transactionStoreNamesMap","transformCache","reverseTransformCache","idbProxyTraps","target","prop","receiver","IDBTransaction","objectStoreNames","objectStore","wrap","wrapFunction","func","IDBDatabase","prototype","transaction","IDBCursor","advance","continue","continuePrimaryKey","unwrap","storeNames","tx","sort","transformCachableValue","done","resolve","unlisten","removeEventListener","complete","DOMException","cacheDonePromiseForTransaction","IDBObjectStore","IDBIndex","some","c","Proxy","IDBRequest","success","promisifyRequest","newValue","readMethods","writeMethods","cachedMethods","getMethod","targetFuncName","useIndex","isWrite","storeName","store","shift","oldTraps","callback","CACHE_OBJECT_STORE","normalizeURL","unNormalizedUrl","hash","CacheTimestampsModel","_db","_cacheName","_upgradeDb","db","objStore","createObjectStore","keyPath","createIndex","unique","_upgradeDbAndDeleteOldDbs","blocked","indexedDB","deleteDatabase","oldVersion","deleteDB","setTimestamp","timestamp","id","_getId","getDb","durability","put","getTimestamp","expireEntries","minTimestamp","maxCount","cursor","openCursor","entriesToDelete","entriesNotDeletedCount","urlsDeleted","delete","version","upgrade","blocking","terminated","open","openPromise","newVersion","openDB","CacheExpiration","config","_isRunning","_rerunRequested","maxEntries","maxAgeSeconds","_maxEntries","_maxAgeSeconds","_matchOptions","matchOptions","_timestampModel","Date","now","urlsExpired","cache","caches","updateTimestamp","isURLExpired","expireOlderThan","Infinity","CacheableResponse","statuses","headers","_statuses","_headers","isResponseCacheable","response","Response","cacheable","headerName","logFriendlyHeaders","stripParams","fullURL","ignoreParams","strippedURL","param","searchParams","Deferred","toRequest","input","StrategyHandler","strategy","options","_cacheKeys","ExtendableEvent","_strategy","_handlerDeferred","_extendLifetimePromises","_plugins","plugins","_pluginStateMap","plugin","fetch","mode","FetchEvent","preloadResponse","possiblePreloadResponse","originalRequest","hasCallback","clone","cb","iterateCallbacks","pluginFilteredRequest","fetchResponse","fetchOptions","runCallbacks","fetchAndCachePut","responseClone","cachePut","cacheMatch","cachedResponse","effectiveRequest","getCacheKey","multiMatchOptions","ms","setTimeout","vary","responseToCache","_ensureResponseSafeToCache","hasCacheUpdateCallback","oldResponse","strippedRequestURL","keysOptions","ignoreSearch","cacheKeys","cacheKey","cacheMatchIgnoreParams","executeQuotaErrorCallbacks","newResponse","state","statefulCallback","statefulParam","doneWaiting","destroy","pluginsUsed","Strategy","responseDone","handleAll","_getResponse","_awaitComplete","_handle","waitUntilError","messages","strategyName","cacheOkAndOpaquePlugin","cacheWillUpdate","asyncFn","returnPromise","createCacheKey","urlObject","revision","cacheKeyURL","originalURL","PrecacheInstallReportPlugin","updatedURLs","notUpdatedURLs","handlerWillStart","cachedResponseWillBeUsed","PrecacheCacheKeyPlugin","precacheController","cacheKeyWillBeUsed","_precacheController","getCacheKeyForURL","printCleanupDetails","deletedURLs","deletionCount","groupTitle","logGroup","_nestedGroup","urls","supportStatus","copyResponse","modifier","clonedResponse","responseInit","Headers","statusText","modifiedResponseInit","body","testResponse","canConstructResponseFromBodyStream","blob","PrecacheStrategy","_fallbackToNetwork","fallbackToNetwork","copyRedirectedCacheableResponsesPlugin","_handleInstall","_handleFetch","integrityInManifest","integrity","integrityInRequest","noIntegrityConflict","_useDefaultCacheabilityPluginIfNeeded","defaultPluginIndex","cacheWillUpdatePluginCount","entries","defaultPrecacheCacheabilityPlugin","redirected","PrecacheController","_urlsToCacheKeys","_urlsToCacheModes","_cacheKeysToIntegrities","install","activate","addToCacheList","_installAndActiveListenersAdded","urlsToWarnAbout","cacheMode","warningMessage","installReportPlugin","credentials","urlsToPrecache","urlsAlreadyPrecached","precachedCount","alreadyPrecachedCount","printInstallDetails","currentlyCachedRequests","expectedCacheKeys","values","getURLsToCacheKeys","getCachedURLs","getIntegrityForCacheKey","matchPrecache","createHandlerBoundToURL","getOrCreatePrecacheController","PrecacheRoute","urlsToCacheKeys","possibleURL","ignoreURLParametersMatching","directoryIndex","cleanURLs","urlManipulation","urlWithoutIgnoredParams","removeIgnoredSearchParams","endsWith","directoryURL","cleanURL","additionalURLs","urlToAttempt","generateURLVariations","CacheFirst","logs","CacheableResponsePlugin","_cacheableResponse","ExpirationPlugin","isFresh","_isResponseDateFresh","cacheExpiration","_getCacheExpiration","updateTimestampDone","cacheDidUpdate","_config","_cacheExpirations","purgeOnQuotaError","add","registerQuotaErrorCallback","deleteCacheAndMetadata","dateHeaderTimestamp","_getDateHeaderTimestamp","dateHeader","headerTime","getTime","isNaN","NetworkFirst","p","unshift","_networkTimeoutSeconds","networkTimeoutSeconds","promises","timeoutId","_getTimeoutPromise","networkPromise","_getNetworkPromise","race","fetchError","clearTimeout","cleanupOutdatedCaches","currentPrecacheName","substringToFind","cacheNamesToDelete","deleteOutdatedCaches","cachesDeleted","clientsClaim","clients","claim","precacheAndRoute","addRoute"],"sources":["workbox-9be7f7ba.js"],"mappings":"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","ignoreList":[],"sourcesContent":["define(['exports'], (function (exports) { 'use strict';\n\n    // @ts-ignore\n    try {\n      self['workbox:core:7.2.0'] && _();\n    } catch (e) {}\n\n    /*\n      Copyright 2019 Google LLC\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    const logger = (() => {\n      // Don't overwrite this value if it's already set.\n      // See https://github.com/GoogleChrome/workbox/pull/2284#issuecomment-560470923\n      if (!('__WB_DISABLE_DEV_LOGS' in globalThis)) {\n        self.__WB_DISABLE_DEV_LOGS = false;\n      }\n      let inGroup = false;\n      const methodToColorMap = {\n        debug: `#7f8c8d`,\n        log: `#2ecc71`,\n        warn: `#f39c12`,\n        error: `#c0392b`,\n        groupCollapsed: `#3498db`,\n        groupEnd: null // No colored prefix on groupEnd\n      };\n      const print = function (method, args) {\n        if (self.__WB_DISABLE_DEV_LOGS) {\n          return;\n        }\n        if (method === 'groupCollapsed') {\n          // Safari doesn't print all console.groupCollapsed() arguments:\n          // https://bugs.webkit.org/show_bug.cgi?id=182754\n          if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n            console[method](...args);\n            return;\n          }\n        }\n        const styles = [`background: ${methodToColorMap[method]}`, `border-radius: 0.5em`, `color: white`, `font-weight: bold`, `padding: 2px 0.5em`];\n        // When in a group, the workbox prefix is not displayed.\n        const logPrefix = inGroup ? [] : ['%cworkbox', styles.join(';')];\n        console[method](...logPrefix, ...args);\n        if (method === 'groupCollapsed') {\n          inGroup = true;\n        }\n        if (method === 'groupEnd') {\n          inGroup = false;\n        }\n      };\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      const api = {};\n      const loggerMethods = Object.keys(methodToColorMap);\n      for (const key of loggerMethods) {\n        const method = key;\n        api[method] = (...args) => {\n          print(method, args);\n        };\n      }\n      return api;\n    })();\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    const messages$1 = {\n      'invalid-value': ({\n        paramName,\n        validValueDescription,\n        value\n      }) => {\n        if (!paramName || !validValueDescription) {\n          throw new Error(`Unexpected input to 'invalid-value' error.`);\n        }\n        return `The '${paramName}' parameter was given a value with an ` + `unexpected value. ${validValueDescription} Received a value of ` + `${JSON.stringify(value)}.`;\n      },\n      'not-an-array': ({\n        moduleName,\n        className,\n        funcName,\n        paramName\n      }) => {\n        if (!moduleName || !className || !funcName || !paramName) {\n          throw new Error(`Unexpected input to 'not-an-array' error.`);\n        }\n        return `The parameter '${paramName}' passed into ` + `'${moduleName}.${className}.${funcName}()' must be an array.`;\n      },\n      'incorrect-type': ({\n        expectedType,\n        paramName,\n        moduleName,\n        className,\n        funcName\n      }) => {\n        if (!expectedType || !paramName || !moduleName || !funcName) {\n          throw new Error(`Unexpected input to 'incorrect-type' error.`);\n        }\n        const classNameStr = className ? `${className}.` : '';\n        return `The parameter '${paramName}' passed into ` + `'${moduleName}.${classNameStr}` + `${funcName}()' must be of type ${expectedType}.`;\n      },\n      'incorrect-class': ({\n        expectedClassName,\n        paramName,\n        moduleName,\n        className,\n        funcName,\n        isReturnValueProblem\n      }) => {\n        if (!expectedClassName || !moduleName || !funcName) {\n          throw new Error(`Unexpected input to 'incorrect-class' error.`);\n        }\n        const classNameStr = className ? `${className}.` : '';\n        if (isReturnValueProblem) {\n          return `The return value from ` + `'${moduleName}.${classNameStr}${funcName}()' ` + `must be an instance of class ${expectedClassName}.`;\n        }\n        return `The parameter '${paramName}' passed into ` + `'${moduleName}.${classNameStr}${funcName}()' ` + `must be an instance of class ${expectedClassName}.`;\n      },\n      'missing-a-method': ({\n        expectedMethod,\n        paramName,\n        moduleName,\n        className,\n        funcName\n      }) => {\n        if (!expectedMethod || !paramName || !moduleName || !className || !funcName) {\n          throw new Error(`Unexpected input to 'missing-a-method' error.`);\n        }\n        return `${moduleName}.${className}.${funcName}() expected the ` + `'${paramName}' parameter to expose a '${expectedMethod}' method.`;\n      },\n      'add-to-cache-list-unexpected-type': ({\n        entry\n      }) => {\n        return `An unexpected entry was passed to ` + `'workbox-precaching.PrecacheController.addToCacheList()' The entry ` + `'${JSON.stringify(entry)}' isn't supported. You must supply an array of ` + `strings with one or more characters, objects with a url property or ` + `Request objects.`;\n      },\n      'add-to-cache-list-conflicting-entries': ({\n        firstEntry,\n        secondEntry\n      }) => {\n        if (!firstEntry || !secondEntry) {\n          throw new Error(`Unexpected input to ` + `'add-to-cache-list-duplicate-entries' error.`);\n        }\n        return `Two of the entries passed to ` + `'workbox-precaching.PrecacheController.addToCacheList()' had the URL ` + `${firstEntry} but different revision details. Workbox is ` + `unable to cache and version the asset correctly. Please remove one ` + `of the entries.`;\n      },\n      'plugin-error-request-will-fetch': ({\n        thrownErrorMessage\n      }) => {\n        if (!thrownErrorMessage) {\n          throw new Error(`Unexpected input to ` + `'plugin-error-request-will-fetch', error.`);\n        }\n        return `An error was thrown by a plugins 'requestWillFetch()' method. ` + `The thrown error message was: '${thrownErrorMessage}'.`;\n      },\n      'invalid-cache-name': ({\n        cacheNameId,\n        value\n      }) => {\n        if (!cacheNameId) {\n          throw new Error(`Expected a 'cacheNameId' for error 'invalid-cache-name'`);\n        }\n        return `You must provide a name containing at least one character for ` + `setCacheDetails({${cacheNameId}: '...'}). Received a value of ` + `'${JSON.stringify(value)}'`;\n      },\n      'unregister-route-but-not-found-with-method': ({\n        method\n      }) => {\n        if (!method) {\n          throw new Error(`Unexpected input to ` + `'unregister-route-but-not-found-with-method' error.`);\n        }\n        return `The route you're trying to unregister was not  previously ` + `registered for the method type '${method}'.`;\n      },\n      'unregister-route-route-not-registered': () => {\n        return `The route you're trying to unregister was not previously ` + `registered.`;\n      },\n      'queue-replay-failed': ({\n        name\n      }) => {\n        return `Replaying the background sync queue '${name}' failed.`;\n      },\n      'duplicate-queue-name': ({\n        name\n      }) => {\n        return `The Queue name '${name}' is already being used. ` + `All instances of backgroundSync.Queue must be given unique names.`;\n      },\n      'expired-test-without-max-age': ({\n        methodName,\n        paramName\n      }) => {\n        return `The '${methodName}()' method can only be used when the ` + `'${paramName}' is used in the constructor.`;\n      },\n      'unsupported-route-type': ({\n        moduleName,\n        className,\n        funcName,\n        paramName\n      }) => {\n        return `The supplied '${paramName}' parameter was an unsupported type. ` + `Please check the docs for ${moduleName}.${className}.${funcName} for ` + `valid input types.`;\n      },\n      'not-array-of-class': ({\n        value,\n        expectedClass,\n        moduleName,\n        className,\n        funcName,\n        paramName\n      }) => {\n        return `The supplied '${paramName}' parameter must be an array of ` + `'${expectedClass}' objects. Received '${JSON.stringify(value)},'. ` + `Please check the call to ${moduleName}.${className}.${funcName}() ` + `to fix the issue.`;\n      },\n      'max-entries-or-age-required': ({\n        moduleName,\n        className,\n        funcName\n      }) => {\n        return `You must define either config.maxEntries or config.maxAgeSeconds` + `in ${moduleName}.${className}.${funcName}`;\n      },\n      'statuses-or-headers-required': ({\n        moduleName,\n        className,\n        funcName\n      }) => {\n        return `You must define either config.statuses or config.headers` + `in ${moduleName}.${className}.${funcName}`;\n      },\n      'invalid-string': ({\n        moduleName,\n        funcName,\n        paramName\n      }) => {\n        if (!paramName || !moduleName || !funcName) {\n          throw new Error(`Unexpected input to 'invalid-string' error.`);\n        }\n        return `When using strings, the '${paramName}' parameter must start with ` + `'http' (for cross-origin matches) or '/' (for same-origin matches). ` + `Please see the docs for ${moduleName}.${funcName}() for ` + `more info.`;\n      },\n      'channel-name-required': () => {\n        return `You must provide a channelName to construct a ` + `BroadcastCacheUpdate instance.`;\n      },\n      'invalid-responses-are-same-args': () => {\n        return `The arguments passed into responsesAreSame() appear to be ` + `invalid. Please ensure valid Responses are used.`;\n      },\n      'expire-custom-caches-only': () => {\n        return `You must provide a 'cacheName' property when using the ` + `expiration plugin with a runtime caching strategy.`;\n      },\n      'unit-must-be-bytes': ({\n        normalizedRangeHeader\n      }) => {\n        if (!normalizedRangeHeader) {\n          throw new Error(`Unexpected input to 'unit-must-be-bytes' error.`);\n        }\n        return `The 'unit' portion of the Range header must be set to 'bytes'. ` + `The Range header provided was \"${normalizedRangeHeader}\"`;\n      },\n      'single-range-only': ({\n        normalizedRangeHeader\n      }) => {\n        if (!normalizedRangeHeader) {\n          throw new Error(`Unexpected input to 'single-range-only' error.`);\n        }\n        return `Multiple ranges are not supported. Please use a  single start ` + `value, and optional end value. The Range header provided was ` + `\"${normalizedRangeHeader}\"`;\n      },\n      'invalid-range-values': ({\n        normalizedRangeHeader\n      }) => {\n        if (!normalizedRangeHeader) {\n          throw new Error(`Unexpected input to 'invalid-range-values' error.`);\n        }\n        return `The Range header is missing both start and end values. At least ` + `one of those values is needed. The Range header provided was ` + `\"${normalizedRangeHeader}\"`;\n      },\n      'no-range-header': () => {\n        return `No Range header was found in the Request provided.`;\n      },\n      'range-not-satisfiable': ({\n        size,\n        start,\n        end\n      }) => {\n        return `The start (${start}) and end (${end}) values in the Range are ` + `not satisfiable by the cached response, which is ${size} bytes.`;\n      },\n      'attempt-to-cache-non-get-request': ({\n        url,\n        method\n      }) => {\n        return `Unable to cache '${url}' because it is a '${method}' request and ` + `only 'GET' requests can be cached.`;\n      },\n      'cache-put-with-no-response': ({\n        url\n      }) => {\n        return `There was an attempt to cache '${url}' but the response was not ` + `defined.`;\n      },\n      'no-response': ({\n        url,\n        error\n      }) => {\n        let message = `The strategy could not generate a response for '${url}'.`;\n        if (error) {\n          message += ` The underlying error is ${error}.`;\n        }\n        return message;\n      },\n      'bad-precaching-response': ({\n        url,\n        status\n      }) => {\n        return `The precaching request for '${url}' failed` + (status ? ` with an HTTP status of ${status}.` : `.`);\n      },\n      'non-precached-url': ({\n        url\n      }) => {\n        return `createHandlerBoundToURL('${url}') was called, but that URL is ` + `not precached. Please pass in a URL that is precached instead.`;\n      },\n      'add-to-cache-list-conflicting-integrities': ({\n        url\n      }) => {\n        return `Two of the entries passed to ` + `'workbox-precaching.PrecacheController.addToCacheList()' had the URL ` + `${url} with different integrity values. Please remove one of them.`;\n      },\n      'missing-precache-entry': ({\n        cacheName,\n        url\n      }) => {\n        return `Unable to find a precached response in ${cacheName} for ${url}.`;\n      },\n      'cross-origin-copy-response': ({\n        origin\n      }) => {\n        return `workbox-core.copyResponse() can only be used with same-origin ` + `responses. It was passed a response with origin ${origin}.`;\n      },\n      'opaque-streams-source': ({\n        type\n      }) => {\n        const message = `One of the workbox-streams sources resulted in an ` + `'${type}' response.`;\n        if (type === 'opaqueredirect') {\n          return `${message} Please do not use a navigation request that results ` + `in a redirect as a source.`;\n        }\n        return `${message} Please ensure your sources are CORS-enabled.`;\n      }\n    };\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    const generatorFunction = (code, details = {}) => {\n      const message = messages$1[code];\n      if (!message) {\n        throw new Error(`Unable to find message for code '${code}'.`);\n      }\n      return message(details);\n    };\n    const messageGenerator = generatorFunction;\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Workbox errors should be thrown with this class.\n     * This allows use to ensure the type easily in tests,\n     * helps developers identify errors from workbox\n     * easily and allows use to optimise error\n     * messages correctly.\n     *\n     * @private\n     */\n    class WorkboxError extends Error {\n      /**\n       *\n       * @param {string} errorCode The error code that\n       * identifies this particular error.\n       * @param {Object=} details Any relevant arguments\n       * that will help developers identify issues should\n       * be added as a key on the context object.\n       */\n      constructor(errorCode, details) {\n        const message = messageGenerator(errorCode, details);\n        super(message);\n        this.name = errorCode;\n        this.details = details;\n      }\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /*\n     * This method throws if the supplied value is not an array.\n     * The destructed values are required to produce a meaningful error for users.\n     * The destructed and restructured object is so it's clear what is\n     * needed.\n     */\n    const isArray = (value, details) => {\n      if (!Array.isArray(value)) {\n        throw new WorkboxError('not-an-array', details);\n      }\n    };\n    const hasMethod = (object, expectedMethod, details) => {\n      const type = typeof object[expectedMethod];\n      if (type !== 'function') {\n        details['expectedMethod'] = expectedMethod;\n        throw new WorkboxError('missing-a-method', details);\n      }\n    };\n    const isType = (object, expectedType, details) => {\n      if (typeof object !== expectedType) {\n        details['expectedType'] = expectedType;\n        throw new WorkboxError('incorrect-type', details);\n      }\n    };\n    const isInstance = (object,\n    // Need the general type to do the check later.\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    expectedClass, details) => {\n      if (!(object instanceof expectedClass)) {\n        details['expectedClassName'] = expectedClass.name;\n        throw new WorkboxError('incorrect-class', details);\n      }\n    };\n    const isOneOf = (value, validValues, details) => {\n      if (!validValues.includes(value)) {\n        details['validValueDescription'] = `Valid values are ${JSON.stringify(validValues)}.`;\n        throw new WorkboxError('invalid-value', details);\n      }\n    };\n    const isArrayOfClass = (value,\n    // Need general type to do check later.\n    expectedClass,\n    // eslint-disable-line\n    details) => {\n      const error = new WorkboxError('not-array-of-class', details);\n      if (!Array.isArray(value)) {\n        throw error;\n      }\n      for (const item of value) {\n        if (!(item instanceof expectedClass)) {\n          throw error;\n        }\n      }\n    };\n    const finalAssertExports = {\n      hasMethod,\n      isArray,\n      isInstance,\n      isOneOf,\n      isType,\n      isArrayOfClass\n    };\n\n    // @ts-ignore\n    try {\n      self['workbox:routing:7.2.0'] && _();\n    } catch (e) {}\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * The default HTTP method, 'GET', used when there's no specific method\n     * configured for a route.\n     *\n     * @type {string}\n     *\n     * @private\n     */\n    const defaultMethod = 'GET';\n    /**\n     * The list of valid HTTP methods associated with requests that could be routed.\n     *\n     * @type {Array<string>}\n     *\n     * @private\n     */\n    const validMethods = ['DELETE', 'GET', 'HEAD', 'PATCH', 'POST', 'PUT'];\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * @param {function()|Object} handler Either a function, or an object with a\n     * 'handle' method.\n     * @return {Object} An object with a handle method.\n     *\n     * @private\n     */\n    const normalizeHandler = handler => {\n      if (handler && typeof handler === 'object') {\n        {\n          finalAssertExports.hasMethod(handler, 'handle', {\n            moduleName: 'workbox-routing',\n            className: 'Route',\n            funcName: 'constructor',\n            paramName: 'handler'\n          });\n        }\n        return handler;\n      } else {\n        {\n          finalAssertExports.isType(handler, 'function', {\n            moduleName: 'workbox-routing',\n            className: 'Route',\n            funcName: 'constructor',\n            paramName: 'handler'\n          });\n        }\n        return {\n          handle: handler\n        };\n      }\n    };\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * A `Route` consists of a pair of callback functions, \"match\" and \"handler\".\n     * The \"match\" callback determine if a route should be used to \"handle\" a\n     * request by returning a non-falsy value if it can. The \"handler\" callback\n     * is called when there is a match and should return a Promise that resolves\n     * to a `Response`.\n     *\n     * @memberof workbox-routing\n     */\n    class Route {\n      /**\n       * Constructor for Route class.\n       *\n       * @param {workbox-routing~matchCallback} match\n       * A callback function that determines whether the route matches a given\n       * `fetch` event by returning a non-falsy value.\n       * @param {workbox-routing~handlerCallback} handler A callback\n       * function that returns a Promise resolving to a Response.\n       * @param {string} [method='GET'] The HTTP method to match the Route\n       * against.\n       */\n      constructor(match, handler, method = defaultMethod) {\n        {\n          finalAssertExports.isType(match, 'function', {\n            moduleName: 'workbox-routing',\n            className: 'Route',\n            funcName: 'constructor',\n            paramName: 'match'\n          });\n          if (method) {\n            finalAssertExports.isOneOf(method, validMethods, {\n              paramName: 'method'\n            });\n          }\n        }\n        // These values are referenced directly by Router so cannot be\n        // altered by minificaton.\n        this.handler = normalizeHandler(handler);\n        this.match = match;\n        this.method = method;\n      }\n      /**\n       *\n       * @param {workbox-routing-handlerCallback} handler A callback\n       * function that returns a Promise resolving to a Response\n       */\n      setCatchHandler(handler) {\n        this.catchHandler = normalizeHandler(handler);\n      }\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * RegExpRoute makes it easy to create a regular expression based\n     * {@link workbox-routing.Route}.\n     *\n     * For same-origin requests the RegExp only needs to match part of the URL. For\n     * requests against third-party servers, you must define a RegExp that matches\n     * the start of the URL.\n     *\n     * @memberof workbox-routing\n     * @extends workbox-routing.Route\n     */\n    class RegExpRoute extends Route {\n      /**\n       * If the regular expression contains\n       * [capture groups]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#grouping-back-references},\n       * the captured values will be passed to the\n       * {@link workbox-routing~handlerCallback} `params`\n       * argument.\n       *\n       * @param {RegExp} regExp The regular expression to match against URLs.\n       * @param {workbox-routing~handlerCallback} handler A callback\n       * function that returns a Promise resulting in a Response.\n       * @param {string} [method='GET'] The HTTP method to match the Route\n       * against.\n       */\n      constructor(regExp, handler, method) {\n        {\n          finalAssertExports.isInstance(regExp, RegExp, {\n            moduleName: 'workbox-routing',\n            className: 'RegExpRoute',\n            funcName: 'constructor',\n            paramName: 'pattern'\n          });\n        }\n        const match = ({\n          url\n        }) => {\n          const result = regExp.exec(url.href);\n          // Return immediately if there's no match.\n          if (!result) {\n            return;\n          }\n          // Require that the match start at the first character in the URL string\n          // if it's a cross-origin request.\n          // See https://github.com/GoogleChrome/workbox/issues/281 for the context\n          // behind this behavior.\n          if (url.origin !== location.origin && result.index !== 0) {\n            {\n              logger.debug(`The regular expression '${regExp.toString()}' only partially matched ` + `against the cross-origin URL '${url.toString()}'. RegExpRoute's will only ` + `handle cross-origin requests if they match the entire URL.`);\n            }\n            return;\n          }\n          // If the route matches, but there aren't any capture groups defined, then\n          // this will return [], which is truthy and therefore sufficient to\n          // indicate a match.\n          // If there are capture groups, then it will return their values.\n          return result.slice(1);\n        };\n        super(match, handler, method);\n      }\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    const getFriendlyURL = url => {\n      const urlObj = new URL(String(url), location.href);\n      // See https://github.com/GoogleChrome/workbox/issues/2323\n      // We want to include everything, except for the origin if it's same-origin.\n      return urlObj.href.replace(new RegExp(`^${location.origin}`), '');\n    };\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * The Router can be used to process a `FetchEvent` using one or more\n     * {@link workbox-routing.Route}, responding with a `Response` if\n     * a matching route exists.\n     *\n     * If no route matches a given a request, the Router will use a \"default\"\n     * handler if one is defined.\n     *\n     * Should the matching Route throw an error, the Router will use a \"catch\"\n     * handler if one is defined to gracefully deal with issues and respond with a\n     * Request.\n     *\n     * If a request matches multiple routes, the **earliest** registered route will\n     * be used to respond to the request.\n     *\n     * @memberof workbox-routing\n     */\n    class Router {\n      /**\n       * Initializes a new Router.\n       */\n      constructor() {\n        this._routes = new Map();\n        this._defaultHandlerMap = new Map();\n      }\n      /**\n       * @return {Map<string, Array<workbox-routing.Route>>} routes A `Map` of HTTP\n       * method name ('GET', etc.) to an array of all the corresponding `Route`\n       * instances that are registered.\n       */\n      get routes() {\n        return this._routes;\n      }\n      /**\n       * Adds a fetch event listener to respond to events when a route matches\n       * the event's request.\n       */\n      addFetchListener() {\n        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n        self.addEventListener('fetch', event => {\n          const {\n            request\n          } = event;\n          const responsePromise = this.handleRequest({\n            request,\n            event\n          });\n          if (responsePromise) {\n            event.respondWith(responsePromise);\n          }\n        });\n      }\n      /**\n       * Adds a message event listener for URLs to cache from the window.\n       * This is useful to cache resources loaded on the page prior to when the\n       * service worker started controlling it.\n       *\n       * The format of the message data sent from the window should be as follows.\n       * Where the `urlsToCache` array may consist of URL strings or an array of\n       * URL string + `requestInit` object (the same as you'd pass to `fetch()`).\n       *\n       * ```\n       * {\n       *   type: 'CACHE_URLS',\n       *   payload: {\n       *     urlsToCache: [\n       *       './script1.js',\n       *       './script2.js',\n       *       ['./script3.js', {mode: 'no-cors'}],\n       *     ],\n       *   },\n       * }\n       * ```\n       */\n      addCacheListener() {\n        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n        self.addEventListener('message', event => {\n          // event.data is type 'any'\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n          if (event.data && event.data.type === 'CACHE_URLS') {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const {\n              payload\n            } = event.data;\n            {\n              logger.debug(`Caching URLs from the window`, payload.urlsToCache);\n            }\n            const requestPromises = Promise.all(payload.urlsToCache.map(entry => {\n              if (typeof entry === 'string') {\n                entry = [entry];\n              }\n              const request = new Request(...entry);\n              return this.handleRequest({\n                request,\n                event\n              });\n              // TODO(philipwalton): TypeScript errors without this typecast for\n              // some reason (probably a bug). The real type here should work but\n              // doesn't: `Array<Promise<Response> | undefined>`.\n            })); // TypeScript\n            event.waitUntil(requestPromises);\n            // If a MessageChannel was used, reply to the message on success.\n            if (event.ports && event.ports[0]) {\n              void requestPromises.then(() => event.ports[0].postMessage(true));\n            }\n          }\n        });\n      }\n      /**\n       * Apply the routing rules to a FetchEvent object to get a Response from an\n       * appropriate Route's handler.\n       *\n       * @param {Object} options\n       * @param {Request} options.request The request to handle.\n       * @param {ExtendableEvent} options.event The event that triggered the\n       *     request.\n       * @return {Promise<Response>|undefined} A promise is returned if a\n       *     registered route can handle the request. If there is no matching\n       *     route and there's no `defaultHandler`, `undefined` is returned.\n       */\n      handleRequest({\n        request,\n        event\n      }) {\n        {\n          finalAssertExports.isInstance(request, Request, {\n            moduleName: 'workbox-routing',\n            className: 'Router',\n            funcName: 'handleRequest',\n            paramName: 'options.request'\n          });\n        }\n        const url = new URL(request.url, location.href);\n        if (!url.protocol.startsWith('http')) {\n          {\n            logger.debug(`Workbox Router only supports URLs that start with 'http'.`);\n          }\n          return;\n        }\n        const sameOrigin = url.origin === location.origin;\n        const {\n          params,\n          route\n        } = this.findMatchingRoute({\n          event,\n          request,\n          sameOrigin,\n          url\n        });\n        let handler = route && route.handler;\n        const debugMessages = [];\n        {\n          if (handler) {\n            debugMessages.push([`Found a route to handle this request:`, route]);\n            if (params) {\n              debugMessages.push([`Passing the following params to the route's handler:`, params]);\n            }\n          }\n        }\n        // If we don't have a handler because there was no matching route, then\n        // fall back to defaultHandler if that's defined.\n        const method = request.method;\n        if (!handler && this._defaultHandlerMap.has(method)) {\n          {\n            debugMessages.push(`Failed to find a matching route. Falling ` + `back to the default handler for ${method}.`);\n          }\n          handler = this._defaultHandlerMap.get(method);\n        }\n        if (!handler) {\n          {\n            // No handler so Workbox will do nothing. If logs is set of debug\n            // i.e. verbose, we should print out this information.\n            logger.debug(`No route found for: ${getFriendlyURL(url)}`);\n          }\n          return;\n        }\n        {\n          // We have a handler, meaning Workbox is going to handle the route.\n          // print the routing details to the console.\n          logger.groupCollapsed(`Router is responding to: ${getFriendlyURL(url)}`);\n          debugMessages.forEach(msg => {\n            if (Array.isArray(msg)) {\n              logger.log(...msg);\n            } else {\n              logger.log(msg);\n            }\n          });\n          logger.groupEnd();\n        }\n        // Wrap in try and catch in case the handle method throws a synchronous\n        // error. It should still callback to the catch handler.\n        let responsePromise;\n        try {\n          responsePromise = handler.handle({\n            url,\n            request,\n            event,\n            params\n          });\n        } catch (err) {\n          responsePromise = Promise.reject(err);\n        }\n        // Get route's catch handler, if it exists\n        const catchHandler = route && route.catchHandler;\n        if (responsePromise instanceof Promise && (this._catchHandler || catchHandler)) {\n          responsePromise = responsePromise.catch(async err => {\n            // If there's a route catch handler, process that first\n            if (catchHandler) {\n              {\n                // Still include URL here as it will be async from the console group\n                // and may not make sense without the URL\n                logger.groupCollapsed(`Error thrown when responding to: ` + ` ${getFriendlyURL(url)}. Falling back to route's Catch Handler.`);\n                logger.error(`Error thrown by:`, route);\n                logger.error(err);\n                logger.groupEnd();\n              }\n              try {\n                return await catchHandler.handle({\n                  url,\n                  request,\n                  event,\n                  params\n                });\n              } catch (catchErr) {\n                if (catchErr instanceof Error) {\n                  err = catchErr;\n                }\n              }\n            }\n            if (this._catchHandler) {\n              {\n                // Still include URL here as it will be async from the console group\n                // and may not make sense without the URL\n                logger.groupCollapsed(`Error thrown when responding to: ` + ` ${getFriendlyURL(url)}. Falling back to global Catch Handler.`);\n                logger.error(`Error thrown by:`, route);\n                logger.error(err);\n                logger.groupEnd();\n              }\n              return this._catchHandler.handle({\n                url,\n                request,\n                event\n              });\n            }\n            throw err;\n          });\n        }\n        return responsePromise;\n      }\n      /**\n       * Checks a request and URL (and optionally an event) against the list of\n       * registered routes, and if there's a match, returns the corresponding\n       * route along with any params generated by the match.\n       *\n       * @param {Object} options\n       * @param {URL} options.url\n       * @param {boolean} options.sameOrigin The result of comparing `url.origin`\n       *     against the current origin.\n       * @param {Request} options.request The request to match.\n       * @param {Event} options.event The corresponding event.\n       * @return {Object} An object with `route` and `params` properties.\n       *     They are populated if a matching route was found or `undefined`\n       *     otherwise.\n       */\n      findMatchingRoute({\n        url,\n        sameOrigin,\n        request,\n        event\n      }) {\n        const routes = this._routes.get(request.method) || [];\n        for (const route of routes) {\n          let params;\n          // route.match returns type any, not possible to change right now.\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n          const matchResult = route.match({\n            url,\n            sameOrigin,\n            request,\n            event\n          });\n          if (matchResult) {\n            {\n              // Warn developers that using an async matchCallback is almost always\n              // not the right thing to do.\n              if (matchResult instanceof Promise) {\n                logger.warn(`While routing ${getFriendlyURL(url)}, an async ` + `matchCallback function was used. Please convert the ` + `following route to use a synchronous matchCallback function:`, route);\n              }\n            }\n            // See https://github.com/GoogleChrome/workbox/issues/2079\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            params = matchResult;\n            if (Array.isArray(params) && params.length === 0) {\n              // Instead of passing an empty array in as params, use undefined.\n              params = undefined;\n            } else if (matchResult.constructor === Object &&\n            // eslint-disable-line\n            Object.keys(matchResult).length === 0) {\n              // Instead of passing an empty object in as params, use undefined.\n              params = undefined;\n            } else if (typeof matchResult === 'boolean') {\n              // For the boolean value true (rather than just something truth-y),\n              // don't set params.\n              // See https://github.com/GoogleChrome/workbox/pull/2134#issuecomment-513924353\n              params = undefined;\n            }\n            // Return early if have a match.\n            return {\n              route,\n              params\n            };\n          }\n        }\n        // If no match was found above, return and empty object.\n        return {};\n      }\n      /**\n       * Define a default `handler` that's called when no routes explicitly\n       * match the incoming request.\n       *\n       * Each HTTP method ('GET', 'POST', etc.) gets its own default handler.\n       *\n       * Without a default handler, unmatched requests will go against the\n       * network as if there were no service worker present.\n       *\n       * @param {workbox-routing~handlerCallback} handler A callback\n       * function that returns a Promise resulting in a Response.\n       * @param {string} [method='GET'] The HTTP method to associate with this\n       * default handler. Each method has its own default.\n       */\n      setDefaultHandler(handler, method = defaultMethod) {\n        this._defaultHandlerMap.set(method, normalizeHandler(handler));\n      }\n      /**\n       * If a Route throws an error while handling a request, this `handler`\n       * will be called and given a chance to provide a response.\n       *\n       * @param {workbox-routing~handlerCallback} handler A callback\n       * function that returns a Promise resulting in a Response.\n       */\n      setCatchHandler(handler) {\n        this._catchHandler = normalizeHandler(handler);\n      }\n      /**\n       * Registers a route with the router.\n       *\n       * @param {workbox-routing.Route} route The route to register.\n       */\n      registerRoute(route) {\n        {\n          finalAssertExports.isType(route, 'object', {\n            moduleName: 'workbox-routing',\n            className: 'Router',\n            funcName: 'registerRoute',\n            paramName: 'route'\n          });\n          finalAssertExports.hasMethod(route, 'match', {\n            moduleName: 'workbox-routing',\n            className: 'Router',\n            funcName: 'registerRoute',\n            paramName: 'route'\n          });\n          finalAssertExports.isType(route.handler, 'object', {\n            moduleName: 'workbox-routing',\n            className: 'Router',\n            funcName: 'registerRoute',\n            paramName: 'route'\n          });\n          finalAssertExports.hasMethod(route.handler, 'handle', {\n            moduleName: 'workbox-routing',\n            className: 'Router',\n            funcName: 'registerRoute',\n            paramName: 'route.handler'\n          });\n          finalAssertExports.isType(route.method, 'string', {\n            moduleName: 'workbox-routing',\n            className: 'Router',\n            funcName: 'registerRoute',\n            paramName: 'route.method'\n          });\n        }\n        if (!this._routes.has(route.method)) {\n          this._routes.set(route.method, []);\n        }\n        // Give precedence to all of the earlier routes by adding this additional\n        // route to the end of the array.\n        this._routes.get(route.method).push(route);\n      }\n      /**\n       * Unregisters a route with the router.\n       *\n       * @param {workbox-routing.Route} route The route to unregister.\n       */\n      unregisterRoute(route) {\n        if (!this._routes.has(route.method)) {\n          throw new WorkboxError('unregister-route-but-not-found-with-method', {\n            method: route.method\n          });\n        }\n        const routeIndex = this._routes.get(route.method).indexOf(route);\n        if (routeIndex > -1) {\n          this._routes.get(route.method).splice(routeIndex, 1);\n        } else {\n          throw new WorkboxError('unregister-route-route-not-registered');\n        }\n      }\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    let defaultRouter;\n    /**\n     * Creates a new, singleton Router instance if one does not exist. If one\n     * does already exist, that instance is returned.\n     *\n     * @private\n     * @return {Router}\n     */\n    const getOrCreateDefaultRouter = () => {\n      if (!defaultRouter) {\n        defaultRouter = new Router();\n        // The helpers that use the default Router assume these listeners exist.\n        defaultRouter.addFetchListener();\n        defaultRouter.addCacheListener();\n      }\n      return defaultRouter;\n    };\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Easily register a RegExp, string, or function with a caching\n     * strategy to a singleton Router instance.\n     *\n     * This method will generate a Route for you if needed and\n     * call {@link workbox-routing.Router#registerRoute}.\n     *\n     * @param {RegExp|string|workbox-routing.Route~matchCallback|workbox-routing.Route} capture\n     * If the capture param is a `Route`, all other arguments will be ignored.\n     * @param {workbox-routing~handlerCallback} [handler] A callback\n     * function that returns a Promise resulting in a Response. This parameter\n     * is required if `capture` is not a `Route` object.\n     * @param {string} [method='GET'] The HTTP method to match the Route\n     * against.\n     * @return {workbox-routing.Route} The generated `Route`.\n     *\n     * @memberof workbox-routing\n     */\n    function registerRoute(capture, handler, method) {\n      let route;\n      if (typeof capture === 'string') {\n        const captureUrl = new URL(capture, location.href);\n        {\n          if (!(capture.startsWith('/') || capture.startsWith('http'))) {\n            throw new WorkboxError('invalid-string', {\n              moduleName: 'workbox-routing',\n              funcName: 'registerRoute',\n              paramName: 'capture'\n            });\n          }\n          // We want to check if Express-style wildcards are in the pathname only.\n          // TODO: Remove this log message in v4.\n          const valueToCheck = capture.startsWith('http') ? captureUrl.pathname : capture;\n          // See https://github.com/pillarjs/path-to-regexp#parameters\n          const wildcards = '[*:?+]';\n          if (new RegExp(`${wildcards}`).exec(valueToCheck)) {\n            logger.debug(`The '$capture' parameter contains an Express-style wildcard ` + `character (${wildcards}). Strings are now always interpreted as ` + `exact matches; use a RegExp for partial or wildcard matches.`);\n          }\n        }\n        const matchCallback = ({\n          url\n        }) => {\n          {\n            if (url.pathname === captureUrl.pathname && url.origin !== captureUrl.origin) {\n              logger.debug(`${capture} only partially matches the cross-origin URL ` + `${url.toString()}. This route will only handle cross-origin requests ` + `if they match the entire URL.`);\n            }\n          }\n          return url.href === captureUrl.href;\n        };\n        // If `capture` is a string then `handler` and `method` must be present.\n        route = new Route(matchCallback, handler, method);\n      } else if (capture instanceof RegExp) {\n        // If `capture` is a `RegExp` then `handler` and `method` must be present.\n        route = new RegExpRoute(capture, handler, method);\n      } else if (typeof capture === 'function') {\n        // If `capture` is a function then `handler` and `method` must be present.\n        route = new Route(capture, handler, method);\n      } else if (capture instanceof Route) {\n        route = capture;\n      } else {\n        throw new WorkboxError('unsupported-route-type', {\n          moduleName: 'workbox-routing',\n          funcName: 'registerRoute',\n          paramName: 'capture'\n        });\n      }\n      const defaultRouter = getOrCreateDefaultRouter();\n      defaultRouter.registerRoute(route);\n      return route;\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    const _cacheNameDetails = {\n      googleAnalytics: 'googleAnalytics',\n      precache: 'precache-v2',\n      prefix: 'workbox',\n      runtime: 'runtime',\n      suffix: typeof registration !== 'undefined' ? registration.scope : ''\n    };\n    const _createCacheName = cacheName => {\n      return [_cacheNameDetails.prefix, cacheName, _cacheNameDetails.suffix].filter(value => value && value.length > 0).join('-');\n    };\n    const eachCacheNameDetail = fn => {\n      for (const key of Object.keys(_cacheNameDetails)) {\n        fn(key);\n      }\n    };\n    const cacheNames = {\n      updateDetails: details => {\n        eachCacheNameDetail(key => {\n          if (typeof details[key] === 'string') {\n            _cacheNameDetails[key] = details[key];\n          }\n        });\n      },\n      getGoogleAnalyticsName: userCacheName => {\n        return userCacheName || _createCacheName(_cacheNameDetails.googleAnalytics);\n      },\n      getPrecacheName: userCacheName => {\n        return userCacheName || _createCacheName(_cacheNameDetails.precache);\n      },\n      getPrefix: () => {\n        return _cacheNameDetails.prefix;\n      },\n      getRuntimeName: userCacheName => {\n        return userCacheName || _createCacheName(_cacheNameDetails.runtime);\n      },\n      getSuffix: () => {\n        return _cacheNameDetails.suffix;\n      }\n    };\n\n    /*\n      Copyright 2019 Google LLC\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * A helper function that prevents a promise from being flagged as unused.\n     *\n     * @private\n     **/\n    function dontWaitFor(promise) {\n      // Effective no-op.\n      void promise.then(() => {});\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    // Callbacks to be executed whenever there's a quota error.\n    // Can't change Function type right now.\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    const quotaErrorCallbacks = new Set();\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Adds a function to the set of quotaErrorCallbacks that will be executed if\n     * there's a quota error.\n     *\n     * @param {Function} callback\n     * @memberof workbox-core\n     */\n    // Can't change Function type\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    function registerQuotaErrorCallback(callback) {\n      {\n        finalAssertExports.isType(callback, 'function', {\n          moduleName: 'workbox-core',\n          funcName: 'register',\n          paramName: 'callback'\n        });\n      }\n      quotaErrorCallbacks.add(callback);\n      {\n        logger.log('Registered a callback to respond to quota errors.', callback);\n      }\n    }\n\n    function _extends() {\n      return _extends = Object.assign ? Object.assign.bind() : function (n) {\n        for (var e = 1; e < arguments.length; e++) {\n          var t = arguments[e];\n          for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n        }\n        return n;\n      }, _extends.apply(null, arguments);\n    }\n\n    const instanceOfAny = (object, constructors) => constructors.some(c => object instanceof c);\n    let idbProxyableTypes;\n    let cursorAdvanceMethods;\n    // This is a function to prevent it throwing up in node environments.\n    function getIdbProxyableTypes() {\n      return idbProxyableTypes || (idbProxyableTypes = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]);\n    }\n    // This is a function to prevent it throwing up in node environments.\n    function getCursorAdvanceMethods() {\n      return cursorAdvanceMethods || (cursorAdvanceMethods = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey]);\n    }\n    const cursorRequestMap = new WeakMap();\n    const transactionDoneMap = new WeakMap();\n    const transactionStoreNamesMap = new WeakMap();\n    const transformCache = new WeakMap();\n    const reverseTransformCache = new WeakMap();\n    function promisifyRequest(request) {\n      const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n          request.removeEventListener('success', success);\n          request.removeEventListener('error', error);\n        };\n        const success = () => {\n          resolve(wrap(request.result));\n          unlisten();\n        };\n        const error = () => {\n          reject(request.error);\n          unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n      });\n      promise.then(value => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n          cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n      }).catch(() => {});\n      // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n      // is because we create many promises from a single IDBRequest.\n      reverseTransformCache.set(promise, request);\n      return promise;\n    }\n    function cacheDonePromiseForTransaction(tx) {\n      // Early bail if we've already created a done promise for this transaction.\n      if (transactionDoneMap.has(tx)) return;\n      const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n          tx.removeEventListener('complete', complete);\n          tx.removeEventListener('error', error);\n          tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n          resolve();\n          unlisten();\n        };\n        const error = () => {\n          reject(tx.error || new DOMException('AbortError', 'AbortError'));\n          unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n      });\n      // Cache it for later retrieval.\n      transactionDoneMap.set(tx, done);\n    }\n    let idbProxyTraps = {\n      get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n          // Special handling for transaction.done.\n          if (prop === 'done') return transactionDoneMap.get(target);\n          // Polyfill for objectStoreNames because of Edge.\n          if (prop === 'objectStoreNames') {\n            return target.objectStoreNames || transactionStoreNamesMap.get(target);\n          }\n          // Make tx.store return the only store in the transaction, or undefined if there are many.\n          if (prop === 'store') {\n            return receiver.objectStoreNames[1] ? undefined : receiver.objectStore(receiver.objectStoreNames[0]);\n          }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n      },\n      set(target, prop, value) {\n        target[prop] = value;\n        return true;\n      },\n      has(target, prop) {\n        if (target instanceof IDBTransaction && (prop === 'done' || prop === 'store')) {\n          return true;\n        }\n        return prop in target;\n      }\n    };\n    function replaceTraps(callback) {\n      idbProxyTraps = callback(idbProxyTraps);\n    }\n    function wrapFunction(func) {\n      // Due to expected object equality (which is enforced by the caching in `wrap`), we\n      // only create one new func per func.\n      // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n      if (func === IDBDatabase.prototype.transaction && !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n          const tx = func.call(unwrap(this), storeNames, ...args);\n          transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n          return wrap(tx);\n        };\n      }\n      // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n      // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n      // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n      // with real promises, so each advance methods returns a new promise for the cursor object, or\n      // undefined if the end of the cursor has been reached.\n      if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n          // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n          // the original object.\n          func.apply(unwrap(this), args);\n          return wrap(cursorRequestMap.get(this));\n        };\n      }\n      return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n      };\n    }\n    function transformCachableValue(value) {\n      if (typeof value === 'function') return wrapFunction(value);\n      // This doesn't return, it just creates a 'done' promise for the transaction,\n      // which is later returned for transaction.done (see idbObjectHandler).\n      if (value instanceof IDBTransaction) cacheDonePromiseForTransaction(value);\n      if (instanceOfAny(value, getIdbProxyableTypes())) return new Proxy(value, idbProxyTraps);\n      // Return the same value back if we're not going to transform it.\n      return value;\n    }\n    function wrap(value) {\n      // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n      // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n      if (value instanceof IDBRequest) return promisifyRequest(value);\n      // If we've already transformed this value before, reuse the transformed value.\n      // This is faster, but it also provides object equality.\n      if (transformCache.has(value)) return transformCache.get(value);\n      const newValue = transformCachableValue(value);\n      // Not all types are transformed.\n      // These may be primitive types, so they can't be WeakMap keys.\n      if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n      }\n      return newValue;\n    }\n    const unwrap = value => reverseTransformCache.get(value);\n\n    /**\n     * Open a database.\n     *\n     * @param name Name of the database.\n     * @param version Schema version.\n     * @param callbacks Additional callbacks.\n     */\n    function openDB(name, version, {\n      blocked,\n      upgrade,\n      blocking,\n      terminated\n    } = {}) {\n      const request = indexedDB.open(name, version);\n      const openPromise = wrap(request);\n      if (upgrade) {\n        request.addEventListener('upgradeneeded', event => {\n          upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n      }\n      if (blocked) {\n        request.addEventListener('blocked', event => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n      }\n      openPromise.then(db => {\n        if (terminated) db.addEventListener('close', () => terminated());\n        if (blocking) {\n          db.addEventListener('versionchange', event => blocking(event.oldVersion, event.newVersion, event));\n        }\n      }).catch(() => {});\n      return openPromise;\n    }\n    /**\n     * Delete a database.\n     *\n     * @param name Name of the database.\n     */\n    function deleteDB(name, {\n      blocked\n    } = {}) {\n      const request = indexedDB.deleteDatabase(name);\n      if (blocked) {\n        request.addEventListener('blocked', event => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n      }\n      return wrap(request).then(() => undefined);\n    }\n    const readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\n    const writeMethods = ['put', 'add', 'delete', 'clear'];\n    const cachedMethods = new Map();\n    function getMethod(target, prop) {\n      if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === 'string')) {\n        return;\n      }\n      if (cachedMethods.get(prop)) return cachedMethods.get(prop);\n      const targetFuncName = prop.replace(/FromIndex$/, '');\n      const useIndex = prop !== targetFuncName;\n      const isWrite = writeMethods.includes(targetFuncName);\n      if (\n      // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n      !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n      }\n      const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex) target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([target[targetFuncName](...args), isWrite && tx.done]))[0];\n      };\n      cachedMethods.set(prop, method);\n      return method;\n    }\n    replaceTraps(oldTraps => _extends({}, oldTraps, {\n      get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n      has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)\n    }));\n\n    // @ts-ignore\n    try {\n      self['workbox:expiration:7.2.0'] && _();\n    } catch (e) {}\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    const DB_NAME = 'workbox-expiration';\n    const CACHE_OBJECT_STORE = 'cache-entries';\n    const normalizeURL = unNormalizedUrl => {\n      const url = new URL(unNormalizedUrl, location.href);\n      url.hash = '';\n      return url.href;\n    };\n    /**\n     * Returns the timestamp model.\n     *\n     * @private\n     */\n    class CacheTimestampsModel {\n      /**\n       *\n       * @param {string} cacheName\n       *\n       * @private\n       */\n      constructor(cacheName) {\n        this._db = null;\n        this._cacheName = cacheName;\n      }\n      /**\n       * Performs an upgrade of indexedDB.\n       *\n       * @param {IDBPDatabase<CacheDbSchema>} db\n       *\n       * @private\n       */\n      _upgradeDb(db) {\n        // TODO(philipwalton): EdgeHTML doesn't support arrays as a keyPath, so we\n        // have to use the `id` keyPath here and create our own values (a\n        // concatenation of `url + cacheName`) instead of simply using\n        // `keyPath: ['url', 'cacheName']`, which is supported in other browsers.\n        const objStore = db.createObjectStore(CACHE_OBJECT_STORE, {\n          keyPath: 'id'\n        });\n        // TODO(philipwalton): once we don't have to support EdgeHTML, we can\n        // create a single index with the keyPath `['cacheName', 'timestamp']`\n        // instead of doing both these indexes.\n        objStore.createIndex('cacheName', 'cacheName', {\n          unique: false\n        });\n        objStore.createIndex('timestamp', 'timestamp', {\n          unique: false\n        });\n      }\n      /**\n       * Performs an upgrade of indexedDB and deletes deprecated DBs.\n       *\n       * @param {IDBPDatabase<CacheDbSchema>} db\n       *\n       * @private\n       */\n      _upgradeDbAndDeleteOldDbs(db) {\n        this._upgradeDb(db);\n        if (this._cacheName) {\n          void deleteDB(this._cacheName);\n        }\n      }\n      /**\n       * @param {string} url\n       * @param {number} timestamp\n       *\n       * @private\n       */\n      async setTimestamp(url, timestamp) {\n        url = normalizeURL(url);\n        const entry = {\n          url,\n          timestamp,\n          cacheName: this._cacheName,\n          // Creating an ID from the URL and cache name won't be necessary once\n          // Edge switches to Chromium and all browsers we support work with\n          // array keyPaths.\n          id: this._getId(url)\n        };\n        const db = await this.getDb();\n        const tx = db.transaction(CACHE_OBJECT_STORE, 'readwrite', {\n          durability: 'relaxed'\n        });\n        await tx.store.put(entry);\n        await tx.done;\n      }\n      /**\n       * Returns the timestamp stored for a given URL.\n       *\n       * @param {string} url\n       * @return {number | undefined}\n       *\n       * @private\n       */\n      async getTimestamp(url) {\n        const db = await this.getDb();\n        const entry = await db.get(CACHE_OBJECT_STORE, this._getId(url));\n        return entry === null || entry === void 0 ? void 0 : entry.timestamp;\n      }\n      /**\n       * Iterates through all the entries in the object store (from newest to\n       * oldest) and removes entries once either `maxCount` is reached or the\n       * entry's timestamp is less than `minTimestamp`.\n       *\n       * @param {number} minTimestamp\n       * @param {number} maxCount\n       * @return {Array<string>}\n       *\n       * @private\n       */\n      async expireEntries(minTimestamp, maxCount) {\n        const db = await this.getDb();\n        let cursor = await db.transaction(CACHE_OBJECT_STORE).store.index('timestamp').openCursor(null, 'prev');\n        const entriesToDelete = [];\n        let entriesNotDeletedCount = 0;\n        while (cursor) {\n          const result = cursor.value;\n          // TODO(philipwalton): once we can use a multi-key index, we\n          // won't have to check `cacheName` here.\n          if (result.cacheName === this._cacheName) {\n            // Delete an entry if it's older than the max age or\n            // if we already have the max number allowed.\n            if (minTimestamp && result.timestamp < minTimestamp || maxCount && entriesNotDeletedCount >= maxCount) {\n              // TODO(philipwalton): we should be able to delete the\n              // entry right here, but doing so causes an iteration\n              // bug in Safari stable (fixed in TP). Instead we can\n              // store the keys of the entries to delete, and then\n              // delete the separate transactions.\n              // https://github.com/GoogleChrome/workbox/issues/1978\n              // cursor.delete();\n              // We only need to return the URL, not the whole entry.\n              entriesToDelete.push(cursor.value);\n            } else {\n              entriesNotDeletedCount++;\n            }\n          }\n          cursor = await cursor.continue();\n        }\n        // TODO(philipwalton): once the Safari bug in the following issue is fixed,\n        // we should be able to remove this loop and do the entry deletion in the\n        // cursor loop above:\n        // https://github.com/GoogleChrome/workbox/issues/1978\n        const urlsDeleted = [];\n        for (const entry of entriesToDelete) {\n          await db.delete(CACHE_OBJECT_STORE, entry.id);\n          urlsDeleted.push(entry.url);\n        }\n        return urlsDeleted;\n      }\n      /**\n       * Takes a URL and returns an ID that will be unique in the object store.\n       *\n       * @param {string} url\n       * @return {string}\n       *\n       * @private\n       */\n      _getId(url) {\n        // Creating an ID from the URL and cache name won't be necessary once\n        // Edge switches to Chromium and all browsers we support work with\n        // array keyPaths.\n        return this._cacheName + '|' + normalizeURL(url);\n      }\n      /**\n       * Returns an open connection to the database.\n       *\n       * @private\n       */\n      async getDb() {\n        if (!this._db) {\n          this._db = await openDB(DB_NAME, 1, {\n            upgrade: this._upgradeDbAndDeleteOldDbs.bind(this)\n          });\n        }\n        return this._db;\n      }\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * The `CacheExpiration` class allows you define an expiration and / or\n     * limit on the number of responses stored in a\n     * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).\n     *\n     * @memberof workbox-expiration\n     */\n    class CacheExpiration {\n      /**\n       * To construct a new CacheExpiration instance you must provide at least\n       * one of the `config` properties.\n       *\n       * @param {string} cacheName Name of the cache to apply restrictions to.\n       * @param {Object} config\n       * @param {number} [config.maxEntries] The maximum number of entries to cache.\n       * Entries used the least will be removed as the maximum is reached.\n       * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n       * it's treated as stale and removed.\n       * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)\n       * that will be used when calling `delete()` on the cache.\n       */\n      constructor(cacheName, config = {}) {\n        this._isRunning = false;\n        this._rerunRequested = false;\n        {\n          finalAssertExports.isType(cacheName, 'string', {\n            moduleName: 'workbox-expiration',\n            className: 'CacheExpiration',\n            funcName: 'constructor',\n            paramName: 'cacheName'\n          });\n          if (!(config.maxEntries || config.maxAgeSeconds)) {\n            throw new WorkboxError('max-entries-or-age-required', {\n              moduleName: 'workbox-expiration',\n              className: 'CacheExpiration',\n              funcName: 'constructor'\n            });\n          }\n          if (config.maxEntries) {\n            finalAssertExports.isType(config.maxEntries, 'number', {\n              moduleName: 'workbox-expiration',\n              className: 'CacheExpiration',\n              funcName: 'constructor',\n              paramName: 'config.maxEntries'\n            });\n          }\n          if (config.maxAgeSeconds) {\n            finalAssertExports.isType(config.maxAgeSeconds, 'number', {\n              moduleName: 'workbox-expiration',\n              className: 'CacheExpiration',\n              funcName: 'constructor',\n              paramName: 'config.maxAgeSeconds'\n            });\n          }\n        }\n        this._maxEntries = config.maxEntries;\n        this._maxAgeSeconds = config.maxAgeSeconds;\n        this._matchOptions = config.matchOptions;\n        this._cacheName = cacheName;\n        this._timestampModel = new CacheTimestampsModel(cacheName);\n      }\n      /**\n       * Expires entries for the given cache and given criteria.\n       */\n      async expireEntries() {\n        if (this._isRunning) {\n          this._rerunRequested = true;\n          return;\n        }\n        this._isRunning = true;\n        const minTimestamp = this._maxAgeSeconds ? Date.now() - this._maxAgeSeconds * 1000 : 0;\n        const urlsExpired = await this._timestampModel.expireEntries(minTimestamp, this._maxEntries);\n        // Delete URLs from the cache\n        const cache = await self.caches.open(this._cacheName);\n        for (const url of urlsExpired) {\n          await cache.delete(url, this._matchOptions);\n        }\n        {\n          if (urlsExpired.length > 0) {\n            logger.groupCollapsed(`Expired ${urlsExpired.length} ` + `${urlsExpired.length === 1 ? 'entry' : 'entries'} and removed ` + `${urlsExpired.length === 1 ? 'it' : 'them'} from the ` + `'${this._cacheName}' cache.`);\n            logger.log(`Expired the following ${urlsExpired.length === 1 ? 'URL' : 'URLs'}:`);\n            urlsExpired.forEach(url => logger.log(`    ${url}`));\n            logger.groupEnd();\n          } else {\n            logger.debug(`Cache expiration ran and found no entries to remove.`);\n          }\n        }\n        this._isRunning = false;\n        if (this._rerunRequested) {\n          this._rerunRequested = false;\n          dontWaitFor(this.expireEntries());\n        }\n      }\n      /**\n       * Update the timestamp for the given URL. This ensures the when\n       * removing entries based on maximum entries, most recently used\n       * is accurate or when expiring, the timestamp is up-to-date.\n       *\n       * @param {string} url\n       */\n      async updateTimestamp(url) {\n        {\n          finalAssertExports.isType(url, 'string', {\n            moduleName: 'workbox-expiration',\n            className: 'CacheExpiration',\n            funcName: 'updateTimestamp',\n            paramName: 'url'\n          });\n        }\n        await this._timestampModel.setTimestamp(url, Date.now());\n      }\n      /**\n       * Can be used to check if a URL has expired or not before it's used.\n       *\n       * This requires a look up from IndexedDB, so can be slow.\n       *\n       * Note: This method will not remove the cached entry, call\n       * `expireEntries()` to remove indexedDB and Cache entries.\n       *\n       * @param {string} url\n       * @return {boolean}\n       */\n      async isURLExpired(url) {\n        if (!this._maxAgeSeconds) {\n          {\n            throw new WorkboxError(`expired-test-without-max-age`, {\n              methodName: 'isURLExpired',\n              paramName: 'maxAgeSeconds'\n            });\n          }\n        } else {\n          const timestamp = await this._timestampModel.getTimestamp(url);\n          const expireOlderThan = Date.now() - this._maxAgeSeconds * 1000;\n          return timestamp !== undefined ? timestamp < expireOlderThan : true;\n        }\n      }\n      /**\n       * Removes the IndexedDB object store used to keep track of cache expiration\n       * metadata.\n       */\n      async delete() {\n        // Make sure we don't attempt another rerun if we're called in the middle of\n        // a cache expiration.\n        this._rerunRequested = false;\n        await this._timestampModel.expireEntries(Infinity); // Expires all.\n      }\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * This plugin can be used in a `workbox-strategy` to regularly enforce a\n     * limit on the age and / or the number of cached requests.\n     *\n     * It can only be used with `workbox-strategy` instances that have a\n     * [custom `cacheName` property set](/web/tools/workbox/guides/configure-workbox#custom_cache_names_in_strategies).\n     * In other words, it can't be used to expire entries in strategy that uses the\n     * default runtime cache name.\n     *\n     * Whenever a cached response is used or updated, this plugin will look\n     * at the associated cache and remove any old or extra responses.\n     *\n     * When using `maxAgeSeconds`, responses may be used *once* after expiring\n     * because the expiration clean up will not have occurred until *after* the\n     * cached response has been used. If the response has a \"Date\" header, then\n     * a light weight expiration check is performed and the response will not be\n     * used immediately.\n     *\n     * When using `maxEntries`, the entry least-recently requested will be removed\n     * from the cache first.\n     *\n     * @memberof workbox-expiration\n     */\n    class ExpirationPlugin {\n      /**\n       * @param {ExpirationPluginOptions} config\n       * @param {number} [config.maxEntries] The maximum number of entries to cache.\n       * Entries used the least will be removed as the maximum is reached.\n       * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n       * it's treated as stale and removed.\n       * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)\n       * that will be used when calling `delete()` on the cache.\n       * @param {boolean} [config.purgeOnQuotaError] Whether to opt this cache in to\n       * automatic deletion if the available storage quota has been exceeded.\n       */\n      constructor(config = {}) {\n        /**\n         * A \"lifecycle\" callback that will be triggered automatically by the\n         * `workbox-strategies` handlers when a `Response` is about to be returned\n         * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to\n         * the handler. It allows the `Response` to be inspected for freshness and\n         * prevents it from being used if the `Response`'s `Date` header value is\n         * older than the configured `maxAgeSeconds`.\n         *\n         * @param {Object} options\n         * @param {string} options.cacheName Name of the cache the response is in.\n         * @param {Response} options.cachedResponse The `Response` object that's been\n         *     read from a cache and whose freshness should be checked.\n         * @return {Response} Either the `cachedResponse`, if it's\n         *     fresh, or `null` if the `Response` is older than `maxAgeSeconds`.\n         *\n         * @private\n         */\n        this.cachedResponseWillBeUsed = async ({\n          event,\n          request,\n          cacheName,\n          cachedResponse\n        }) => {\n          if (!cachedResponse) {\n            return null;\n          }\n          const isFresh = this._isResponseDateFresh(cachedResponse);\n          // Expire entries to ensure that even if the expiration date has\n          // expired, it'll only be used once.\n          const cacheExpiration = this._getCacheExpiration(cacheName);\n          dontWaitFor(cacheExpiration.expireEntries());\n          // Update the metadata for the request URL to the current timestamp,\n          // but don't `await` it as we don't want to block the response.\n          const updateTimestampDone = cacheExpiration.updateTimestamp(request.url);\n          if (event) {\n            try {\n              event.waitUntil(updateTimestampDone);\n            } catch (error) {\n              {\n                // The event may not be a fetch event; only log the URL if it is.\n                if ('request' in event) {\n                  logger.warn(`Unable to ensure service worker stays alive when ` + `updating cache entry for ` + `'${getFriendlyURL(event.request.url)}'.`);\n                }\n              }\n            }\n          }\n          return isFresh ? cachedResponse : null;\n        };\n        /**\n         * A \"lifecycle\" callback that will be triggered automatically by the\n         * `workbox-strategies` handlers when an entry is added to a cache.\n         *\n         * @param {Object} options\n         * @param {string} options.cacheName Name of the cache that was updated.\n         * @param {string} options.request The Request for the cached entry.\n         *\n         * @private\n         */\n        this.cacheDidUpdate = async ({\n          cacheName,\n          request\n        }) => {\n          {\n            finalAssertExports.isType(cacheName, 'string', {\n              moduleName: 'workbox-expiration',\n              className: 'Plugin',\n              funcName: 'cacheDidUpdate',\n              paramName: 'cacheName'\n            });\n            finalAssertExports.isInstance(request, Request, {\n              moduleName: 'workbox-expiration',\n              className: 'Plugin',\n              funcName: 'cacheDidUpdate',\n              paramName: 'request'\n            });\n          }\n          const cacheExpiration = this._getCacheExpiration(cacheName);\n          await cacheExpiration.updateTimestamp(request.url);\n          await cacheExpiration.expireEntries();\n        };\n        {\n          if (!(config.maxEntries || config.maxAgeSeconds)) {\n            throw new WorkboxError('max-entries-or-age-required', {\n              moduleName: 'workbox-expiration',\n              className: 'Plugin',\n              funcName: 'constructor'\n            });\n          }\n          if (config.maxEntries) {\n            finalAssertExports.isType(config.maxEntries, 'number', {\n              moduleName: 'workbox-expiration',\n              className: 'Plugin',\n              funcName: 'constructor',\n              paramName: 'config.maxEntries'\n            });\n          }\n          if (config.maxAgeSeconds) {\n            finalAssertExports.isType(config.maxAgeSeconds, 'number', {\n              moduleName: 'workbox-expiration',\n              className: 'Plugin',\n              funcName: 'constructor',\n              paramName: 'config.maxAgeSeconds'\n            });\n          }\n        }\n        this._config = config;\n        this._maxAgeSeconds = config.maxAgeSeconds;\n        this._cacheExpirations = new Map();\n        if (config.purgeOnQuotaError) {\n          registerQuotaErrorCallback(() => this.deleteCacheAndMetadata());\n        }\n      }\n      /**\n       * A simple helper method to return a CacheExpiration instance for a given\n       * cache name.\n       *\n       * @param {string} cacheName\n       * @return {CacheExpiration}\n       *\n       * @private\n       */\n      _getCacheExpiration(cacheName) {\n        if (cacheName === cacheNames.getRuntimeName()) {\n          throw new WorkboxError('expire-custom-caches-only');\n        }\n        let cacheExpiration = this._cacheExpirations.get(cacheName);\n        if (!cacheExpiration) {\n          cacheExpiration = new CacheExpiration(cacheName, this._config);\n          this._cacheExpirations.set(cacheName, cacheExpiration);\n        }\n        return cacheExpiration;\n      }\n      /**\n       * @param {Response} cachedResponse\n       * @return {boolean}\n       *\n       * @private\n       */\n      _isResponseDateFresh(cachedResponse) {\n        if (!this._maxAgeSeconds) {\n          // We aren't expiring by age, so return true, it's fresh\n          return true;\n        }\n        // Check if the 'date' header will suffice a quick expiration check.\n        // See https://github.com/GoogleChromeLabs/sw-toolbox/issues/164 for\n        // discussion.\n        const dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);\n        if (dateHeaderTimestamp === null) {\n          // Unable to parse date, so assume it's fresh.\n          return true;\n        }\n        // If we have a valid headerTime, then our response is fresh iff the\n        // headerTime plus maxAgeSeconds is greater than the current time.\n        const now = Date.now();\n        return dateHeaderTimestamp >= now - this._maxAgeSeconds * 1000;\n      }\n      /**\n       * This method will extract the data header and parse it into a useful\n       * value.\n       *\n       * @param {Response} cachedResponse\n       * @return {number|null}\n       *\n       * @private\n       */\n      _getDateHeaderTimestamp(cachedResponse) {\n        if (!cachedResponse.headers.has('date')) {\n          return null;\n        }\n        const dateHeader = cachedResponse.headers.get('date');\n        const parsedDate = new Date(dateHeader);\n        const headerTime = parsedDate.getTime();\n        // If the Date header was invalid for some reason, parsedDate.getTime()\n        // will return NaN.\n        if (isNaN(headerTime)) {\n          return null;\n        }\n        return headerTime;\n      }\n      /**\n       * This is a helper method that performs two operations:\n       *\n       * - Deletes *all* the underlying Cache instances associated with this plugin\n       * instance, by calling caches.delete() on your behalf.\n       * - Deletes the metadata from IndexedDB used to keep track of expiration\n       * details for each Cache instance.\n       *\n       * When using cache expiration, calling this method is preferable to calling\n       * `caches.delete()` directly, since this will ensure that the IndexedDB\n       * metadata is also cleanly removed and open IndexedDB instances are deleted.\n       *\n       * Note that if you're *not* using cache expiration for a given cache, calling\n       * `caches.delete()` and passing in the cache's name should be sufficient.\n       * There is no Workbox-specific method needed for cleanup in that case.\n       */\n      async deleteCacheAndMetadata() {\n        // Do this one at a time instead of all at once via `Promise.all()` to\n        // reduce the chance of inconsistency if a promise rejects.\n        for (const [cacheName, cacheExpiration] of this._cacheExpirations) {\n          await self.caches.delete(cacheName);\n          await cacheExpiration.delete();\n        }\n        // Reset this._cacheExpirations to its initial state.\n        this._cacheExpirations = new Map();\n      }\n    }\n\n    // @ts-ignore\n    try {\n      self['workbox:cacheable-response:7.2.0'] && _();\n    } catch (e) {}\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * This class allows you to set up rules determining what\n     * status codes and/or headers need to be present in order for a\n     * [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response)\n     * to be considered cacheable.\n     *\n     * @memberof workbox-cacheable-response\n     */\n    class CacheableResponse {\n      /**\n       * To construct a new CacheableResponse instance you must provide at least\n       * one of the `config` properties.\n       *\n       * If both `statuses` and `headers` are specified, then both conditions must\n       * be met for the `Response` to be considered cacheable.\n       *\n       * @param {Object} config\n       * @param {Array<number>} [config.statuses] One or more status codes that a\n       * `Response` can have and be considered cacheable.\n       * @param {Object<string,string>} [config.headers] A mapping of header names\n       * and expected values that a `Response` can have and be considered cacheable.\n       * If multiple headers are provided, only one needs to be present.\n       */\n      constructor(config = {}) {\n        {\n          if (!(config.statuses || config.headers)) {\n            throw new WorkboxError('statuses-or-headers-required', {\n              moduleName: 'workbox-cacheable-response',\n              className: 'CacheableResponse',\n              funcName: 'constructor'\n            });\n          }\n          if (config.statuses) {\n            finalAssertExports.isArray(config.statuses, {\n              moduleName: 'workbox-cacheable-response',\n              className: 'CacheableResponse',\n              funcName: 'constructor',\n              paramName: 'config.statuses'\n            });\n          }\n          if (config.headers) {\n            finalAssertExports.isType(config.headers, 'object', {\n              moduleName: 'workbox-cacheable-response',\n              className: 'CacheableResponse',\n              funcName: 'constructor',\n              paramName: 'config.headers'\n            });\n          }\n        }\n        this._statuses = config.statuses;\n        this._headers = config.headers;\n      }\n      /**\n       * Checks a response to see whether it's cacheable or not, based on this\n       * object's configuration.\n       *\n       * @param {Response} response The response whose cacheability is being\n       * checked.\n       * @return {boolean} `true` if the `Response` is cacheable, and `false`\n       * otherwise.\n       */\n      isResponseCacheable(response) {\n        {\n          finalAssertExports.isInstance(response, Response, {\n            moduleName: 'workbox-cacheable-response',\n            className: 'CacheableResponse',\n            funcName: 'isResponseCacheable',\n            paramName: 'response'\n          });\n        }\n        let cacheable = true;\n        if (this._statuses) {\n          cacheable = this._statuses.includes(response.status);\n        }\n        if (this._headers && cacheable) {\n          cacheable = Object.keys(this._headers).some(headerName => {\n            return response.headers.get(headerName) === this._headers[headerName];\n          });\n        }\n        {\n          if (!cacheable) {\n            logger.groupCollapsed(`The request for ` + `'${getFriendlyURL(response.url)}' returned a response that does ` + `not meet the criteria for being cached.`);\n            logger.groupCollapsed(`View cacheability criteria here.`);\n            logger.log(`Cacheable statuses: ` + JSON.stringify(this._statuses));\n            logger.log(`Cacheable headers: ` + JSON.stringify(this._headers, null, 2));\n            logger.groupEnd();\n            const logFriendlyHeaders = {};\n            response.headers.forEach((value, key) => {\n              logFriendlyHeaders[key] = value;\n            });\n            logger.groupCollapsed(`View response status and headers here.`);\n            logger.log(`Response status: ${response.status}`);\n            logger.log(`Response headers: ` + JSON.stringify(logFriendlyHeaders, null, 2));\n            logger.groupEnd();\n            logger.groupCollapsed(`View full response details here.`);\n            logger.log(response.headers);\n            logger.log(response);\n            logger.groupEnd();\n            logger.groupEnd();\n          }\n        }\n        return cacheable;\n      }\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * A class implementing the `cacheWillUpdate` lifecycle callback. This makes it\n     * easier to add in cacheability checks to requests made via Workbox's built-in\n     * strategies.\n     *\n     * @memberof workbox-cacheable-response\n     */\n    class CacheableResponsePlugin {\n      /**\n       * To construct a new CacheableResponsePlugin instance you must provide at\n       * least one of the `config` properties.\n       *\n       * If both `statuses` and `headers` are specified, then both conditions must\n       * be met for the `Response` to be considered cacheable.\n       *\n       * @param {Object} config\n       * @param {Array<number>} [config.statuses] One or more status codes that a\n       * `Response` can have and be considered cacheable.\n       * @param {Object<string,string>} [config.headers] A mapping of header names\n       * and expected values that a `Response` can have and be considered cacheable.\n       * If multiple headers are provided, only one needs to be present.\n       */\n      constructor(config) {\n        /**\n         * @param {Object} options\n         * @param {Response} options.response\n         * @return {Response|null}\n         * @private\n         */\n        this.cacheWillUpdate = async ({\n          response\n        }) => {\n          if (this._cacheableResponse.isResponseCacheable(response)) {\n            return response;\n          }\n          return null;\n        };\n        this._cacheableResponse = new CacheableResponse(config);\n      }\n    }\n\n    /*\n      Copyright 2020 Google LLC\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    function stripParams(fullURL, ignoreParams) {\n      const strippedURL = new URL(fullURL);\n      for (const param of ignoreParams) {\n        strippedURL.searchParams.delete(param);\n      }\n      return strippedURL.href;\n    }\n    /**\n     * Matches an item in the cache, ignoring specific URL params. This is similar\n     * to the `ignoreSearch` option, but it allows you to ignore just specific\n     * params (while continuing to match on the others).\n     *\n     * @private\n     * @param {Cache} cache\n     * @param {Request} request\n     * @param {Object} matchOptions\n     * @param {Array<string>} ignoreParams\n     * @return {Promise<Response|undefined>}\n     */\n    async function cacheMatchIgnoreParams(cache, request, ignoreParams, matchOptions) {\n      const strippedRequestURL = stripParams(request.url, ignoreParams);\n      // If the request doesn't include any ignored params, match as normal.\n      if (request.url === strippedRequestURL) {\n        return cache.match(request, matchOptions);\n      }\n      // Otherwise, match by comparing keys\n      const keysOptions = Object.assign(Object.assign({}, matchOptions), {\n        ignoreSearch: true\n      });\n      const cacheKeys = await cache.keys(request, keysOptions);\n      for (const cacheKey of cacheKeys) {\n        const strippedCacheKeyURL = stripParams(cacheKey.url, ignoreParams);\n        if (strippedRequestURL === strippedCacheKeyURL) {\n          return cache.match(cacheKey, matchOptions);\n        }\n      }\n      return;\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * The Deferred class composes Promises in a way that allows for them to be\n     * resolved or rejected from outside the constructor. In most cases promises\n     * should be used directly, but Deferreds can be necessary when the logic to\n     * resolve a promise must be separate.\n     *\n     * @private\n     */\n    class Deferred {\n      /**\n       * Creates a promise and exposes its resolve and reject functions as methods.\n       */\n      constructor() {\n        this.promise = new Promise((resolve, reject) => {\n          this.resolve = resolve;\n          this.reject = reject;\n        });\n      }\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Runs all of the callback functions, one at a time sequentially, in the order\n     * in which they were registered.\n     *\n     * @memberof workbox-core\n     * @private\n     */\n    async function executeQuotaErrorCallbacks() {\n      {\n        logger.log(`About to run ${quotaErrorCallbacks.size} ` + `callbacks to clean up caches.`);\n      }\n      for (const callback of quotaErrorCallbacks) {\n        await callback();\n        {\n          logger.log(callback, 'is complete.');\n        }\n      }\n      {\n        logger.log('Finished running callbacks.');\n      }\n    }\n\n    /*\n      Copyright 2019 Google LLC\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Returns a promise that resolves and the passed number of milliseconds.\n     * This utility is an async/await-friendly version of `setTimeout`.\n     *\n     * @param {number} ms\n     * @return {Promise}\n     * @private\n     */\n    function timeout(ms) {\n      return new Promise(resolve => setTimeout(resolve, ms));\n    }\n\n    // @ts-ignore\n    try {\n      self['workbox:strategies:7.2.0'] && _();\n    } catch (e) {}\n\n    /*\n      Copyright 2020 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    function toRequest(input) {\n      return typeof input === 'string' ? new Request(input) : input;\n    }\n    /**\n     * A class created every time a Strategy instance instance calls\n     * {@link workbox-strategies.Strategy~handle} or\n     * {@link workbox-strategies.Strategy~handleAll} that wraps all fetch and\n     * cache actions around plugin callbacks and keeps track of when the strategy\n     * is \"done\" (i.e. all added `event.waitUntil()` promises have resolved).\n     *\n     * @memberof workbox-strategies\n     */\n    class StrategyHandler {\n      /**\n       * Creates a new instance associated with the passed strategy and event\n       * that's handling the request.\n       *\n       * The constructor also initializes the state that will be passed to each of\n       * the plugins handling this request.\n       *\n       * @param {workbox-strategies.Strategy} strategy\n       * @param {Object} options\n       * @param {Request|string} options.request A request to run this strategy for.\n       * @param {ExtendableEvent} options.event The event associated with the\n       *     request.\n       * @param {URL} [options.url]\n       * @param {*} [options.params] The return value from the\n       *     {@link workbox-routing~matchCallback} (if applicable).\n       */\n      constructor(strategy, options) {\n        this._cacheKeys = {};\n        /**\n         * The request the strategy is performing (passed to the strategy's\n         * `handle()` or `handleAll()` method).\n         * @name request\n         * @instance\n         * @type {Request}\n         * @memberof workbox-strategies.StrategyHandler\n         */\n        /**\n         * The event associated with this request.\n         * @name event\n         * @instance\n         * @type {ExtendableEvent}\n         * @memberof workbox-strategies.StrategyHandler\n         */\n        /**\n         * A `URL` instance of `request.url` (if passed to the strategy's\n         * `handle()` or `handleAll()` method).\n         * Note: the `url` param will be present if the strategy was invoked\n         * from a workbox `Route` object.\n         * @name url\n         * @instance\n         * @type {URL|undefined}\n         * @memberof workbox-strategies.StrategyHandler\n         */\n        /**\n         * A `param` value (if passed to the strategy's\n         * `handle()` or `handleAll()` method).\n         * Note: the `param` param will be present if the strategy was invoked\n         * from a workbox `Route` object and the\n         * {@link workbox-routing~matchCallback} returned\n         * a truthy value (it will be that value).\n         * @name params\n         * @instance\n         * @type {*|undefined}\n         * @memberof workbox-strategies.StrategyHandler\n         */\n        {\n          finalAssertExports.isInstance(options.event, ExtendableEvent, {\n            moduleName: 'workbox-strategies',\n            className: 'StrategyHandler',\n            funcName: 'constructor',\n            paramName: 'options.event'\n          });\n        }\n        Object.assign(this, options);\n        this.event = options.event;\n        this._strategy = strategy;\n        this._handlerDeferred = new Deferred();\n        this._extendLifetimePromises = [];\n        // Copy the plugins list (since it's mutable on the strategy),\n        // so any mutations don't affect this handler instance.\n        this._plugins = [...strategy.plugins];\n        this._pluginStateMap = new Map();\n        for (const plugin of this._plugins) {\n          this._pluginStateMap.set(plugin, {});\n        }\n        this.event.waitUntil(this._handlerDeferred.promise);\n      }\n      /**\n       * Fetches a given request (and invokes any applicable plugin callback\n       * methods) using the `fetchOptions` (for non-navigation requests) and\n       * `plugins` defined on the `Strategy` object.\n       *\n       * The following plugin lifecycle methods are invoked when using this method:\n       * - `requestWillFetch()`\n       * - `fetchDidSucceed()`\n       * - `fetchDidFail()`\n       *\n       * @param {Request|string} input The URL or request to fetch.\n       * @return {Promise<Response>}\n       */\n      async fetch(input) {\n        const {\n          event\n        } = this;\n        let request = toRequest(input);\n        if (request.mode === 'navigate' && event instanceof FetchEvent && event.preloadResponse) {\n          const possiblePreloadResponse = await event.preloadResponse;\n          if (possiblePreloadResponse) {\n            {\n              logger.log(`Using a preloaded navigation response for ` + `'${getFriendlyURL(request.url)}'`);\n            }\n            return possiblePreloadResponse;\n          }\n        }\n        // If there is a fetchDidFail plugin, we need to save a clone of the\n        // original request before it's either modified by a requestWillFetch\n        // plugin or before the original request's body is consumed via fetch().\n        const originalRequest = this.hasCallback('fetchDidFail') ? request.clone() : null;\n        try {\n          for (const cb of this.iterateCallbacks('requestWillFetch')) {\n            request = await cb({\n              request: request.clone(),\n              event\n            });\n          }\n        } catch (err) {\n          if (err instanceof Error) {\n            throw new WorkboxError('plugin-error-request-will-fetch', {\n              thrownErrorMessage: err.message\n            });\n          }\n        }\n        // The request can be altered by plugins with `requestWillFetch` making\n        // the original request (most likely from a `fetch` event) different\n        // from the Request we make. Pass both to `fetchDidFail` to aid debugging.\n        const pluginFilteredRequest = request.clone();\n        try {\n          let fetchResponse;\n          // See https://github.com/GoogleChrome/workbox/issues/1796\n          fetchResponse = await fetch(request, request.mode === 'navigate' ? undefined : this._strategy.fetchOptions);\n          if (\"development\" !== 'production') {\n            logger.debug(`Network request for ` + `'${getFriendlyURL(request.url)}' returned a response with ` + `status '${fetchResponse.status}'.`);\n          }\n          for (const callback of this.iterateCallbacks('fetchDidSucceed')) {\n            fetchResponse = await callback({\n              event,\n              request: pluginFilteredRequest,\n              response: fetchResponse\n            });\n          }\n          return fetchResponse;\n        } catch (error) {\n          {\n            logger.log(`Network request for ` + `'${getFriendlyURL(request.url)}' threw an error.`, error);\n          }\n          // `originalRequest` will only exist if a `fetchDidFail` callback\n          // is being used (see above).\n          if (originalRequest) {\n            await this.runCallbacks('fetchDidFail', {\n              error: error,\n              event,\n              originalRequest: originalRequest.clone(),\n              request: pluginFilteredRequest.clone()\n            });\n          }\n          throw error;\n        }\n      }\n      /**\n       * Calls `this.fetch()` and (in the background) runs `this.cachePut()` on\n       * the response generated by `this.fetch()`.\n       *\n       * The call to `this.cachePut()` automatically invokes `this.waitUntil()`,\n       * so you do not have to manually call `waitUntil()` on the event.\n       *\n       * @param {Request|string} input The request or URL to fetch and cache.\n       * @return {Promise<Response>}\n       */\n      async fetchAndCachePut(input) {\n        const response = await this.fetch(input);\n        const responseClone = response.clone();\n        void this.waitUntil(this.cachePut(input, responseClone));\n        return response;\n      }\n      /**\n       * Matches a request from the cache (and invokes any applicable plugin\n       * callback methods) using the `cacheName`, `matchOptions`, and `plugins`\n       * defined on the strategy object.\n       *\n       * The following plugin lifecycle methods are invoked when using this method:\n       * - cacheKeyWillBeUsed()\n       * - cachedResponseWillBeUsed()\n       *\n       * @param {Request|string} key The Request or URL to use as the cache key.\n       * @return {Promise<Response|undefined>} A matching response, if found.\n       */\n      async cacheMatch(key) {\n        const request = toRequest(key);\n        let cachedResponse;\n        const {\n          cacheName,\n          matchOptions\n        } = this._strategy;\n        const effectiveRequest = await this.getCacheKey(request, 'read');\n        const multiMatchOptions = Object.assign(Object.assign({}, matchOptions), {\n          cacheName\n        });\n        cachedResponse = await caches.match(effectiveRequest, multiMatchOptions);\n        {\n          if (cachedResponse) {\n            logger.debug(`Found a cached response in '${cacheName}'.`);\n          } else {\n            logger.debug(`No cached response found in '${cacheName}'.`);\n          }\n        }\n        for (const callback of this.iterateCallbacks('cachedResponseWillBeUsed')) {\n          cachedResponse = (await callback({\n            cacheName,\n            matchOptions,\n            cachedResponse,\n            request: effectiveRequest,\n            event: this.event\n          })) || undefined;\n        }\n        return cachedResponse;\n      }\n      /**\n       * Puts a request/response pair in the cache (and invokes any applicable\n       * plugin callback methods) using the `cacheName` and `plugins` defined on\n       * the strategy object.\n       *\n       * The following plugin lifecycle methods are invoked when using this method:\n       * - cacheKeyWillBeUsed()\n       * - cacheWillUpdate()\n       * - cacheDidUpdate()\n       *\n       * @param {Request|string} key The request or URL to use as the cache key.\n       * @param {Response} response The response to cache.\n       * @return {Promise<boolean>} `false` if a cacheWillUpdate caused the response\n       * not be cached, and `true` otherwise.\n       */\n      async cachePut(key, response) {\n        const request = toRequest(key);\n        // Run in the next task to avoid blocking other cache reads.\n        // https://github.com/w3c/ServiceWorker/issues/1397\n        await timeout(0);\n        const effectiveRequest = await this.getCacheKey(request, 'write');\n        {\n          if (effectiveRequest.method && effectiveRequest.method !== 'GET') {\n            throw new WorkboxError('attempt-to-cache-non-get-request', {\n              url: getFriendlyURL(effectiveRequest.url),\n              method: effectiveRequest.method\n            });\n          }\n          // See https://github.com/GoogleChrome/workbox/issues/2818\n          const vary = response.headers.get('Vary');\n          if (vary) {\n            logger.debug(`The response for ${getFriendlyURL(effectiveRequest.url)} ` + `has a 'Vary: ${vary}' header. ` + `Consider setting the {ignoreVary: true} option on your strategy ` + `to ensure cache matching and deletion works as expected.`);\n          }\n        }\n        if (!response) {\n          {\n            logger.error(`Cannot cache non-existent response for ` + `'${getFriendlyURL(effectiveRequest.url)}'.`);\n          }\n          throw new WorkboxError('cache-put-with-no-response', {\n            url: getFriendlyURL(effectiveRequest.url)\n          });\n        }\n        const responseToCache = await this._ensureResponseSafeToCache(response);\n        if (!responseToCache) {\n          {\n            logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' ` + `will not be cached.`, responseToCache);\n          }\n          return false;\n        }\n        const {\n          cacheName,\n          matchOptions\n        } = this._strategy;\n        const cache = await self.caches.open(cacheName);\n        const hasCacheUpdateCallback = this.hasCallback('cacheDidUpdate');\n        const oldResponse = hasCacheUpdateCallback ? await cacheMatchIgnoreParams(\n        // TODO(philipwalton): the `__WB_REVISION__` param is a precaching\n        // feature. Consider into ways to only add this behavior if using\n        // precaching.\n        cache, effectiveRequest.clone(), ['__WB_REVISION__'], matchOptions) : null;\n        {\n          logger.debug(`Updating the '${cacheName}' cache with a new Response ` + `for ${getFriendlyURL(effectiveRequest.url)}.`);\n        }\n        try {\n          await cache.put(effectiveRequest, hasCacheUpdateCallback ? responseToCache.clone() : responseToCache);\n        } catch (error) {\n          if (error instanceof Error) {\n            // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\n            if (error.name === 'QuotaExceededError') {\n              await executeQuotaErrorCallbacks();\n            }\n            throw error;\n          }\n        }\n        for (const callback of this.iterateCallbacks('cacheDidUpdate')) {\n          await callback({\n            cacheName,\n            oldResponse,\n            newResponse: responseToCache.clone(),\n            request: effectiveRequest,\n            event: this.event\n          });\n        }\n        return true;\n      }\n      /**\n       * Checks the list of plugins for the `cacheKeyWillBeUsed` callback, and\n       * executes any of those callbacks found in sequence. The final `Request`\n       * object returned by the last plugin is treated as the cache key for cache\n       * reads and/or writes. If no `cacheKeyWillBeUsed` plugin callbacks have\n       * been registered, the passed request is returned unmodified\n       *\n       * @param {Request} request\n       * @param {string} mode\n       * @return {Promise<Request>}\n       */\n      async getCacheKey(request, mode) {\n        const key = `${request.url} | ${mode}`;\n        if (!this._cacheKeys[key]) {\n          let effectiveRequest = request;\n          for (const callback of this.iterateCallbacks('cacheKeyWillBeUsed')) {\n            effectiveRequest = toRequest(await callback({\n              mode,\n              request: effectiveRequest,\n              event: this.event,\n              // params has a type any can't change right now.\n              params: this.params // eslint-disable-line\n            }));\n          }\n          this._cacheKeys[key] = effectiveRequest;\n        }\n        return this._cacheKeys[key];\n      }\n      /**\n       * Returns true if the strategy has at least one plugin with the given\n       * callback.\n       *\n       * @param {string} name The name of the callback to check for.\n       * @return {boolean}\n       */\n      hasCallback(name) {\n        for (const plugin of this._strategy.plugins) {\n          if (name in plugin) {\n            return true;\n          }\n        }\n        return false;\n      }\n      /**\n       * Runs all plugin callbacks matching the given name, in order, passing the\n       * given param object (merged ith the current plugin state) as the only\n       * argument.\n       *\n       * Note: since this method runs all plugins, it's not suitable for cases\n       * where the return value of a callback needs to be applied prior to calling\n       * the next callback. See\n       * {@link workbox-strategies.StrategyHandler#iterateCallbacks}\n       * below for how to handle that case.\n       *\n       * @param {string} name The name of the callback to run within each plugin.\n       * @param {Object} param The object to pass as the first (and only) param\n       *     when executing each callback. This object will be merged with the\n       *     current plugin state prior to callback execution.\n       */\n      async runCallbacks(name, param) {\n        for (const callback of this.iterateCallbacks(name)) {\n          // TODO(philipwalton): not sure why `any` is needed. It seems like\n          // this should work with `as WorkboxPluginCallbackParam[C]`.\n          await callback(param);\n        }\n      }\n      /**\n       * Accepts a callback and returns an iterable of matching plugin callbacks,\n       * where each callback is wrapped with the current handler state (i.e. when\n       * you call each callback, whatever object parameter you pass it will\n       * be merged with the plugin's current state).\n       *\n       * @param {string} name The name fo the callback to run\n       * @return {Array<Function>}\n       */\n      *iterateCallbacks(name) {\n        for (const plugin of this._strategy.plugins) {\n          if (typeof plugin[name] === 'function') {\n            const state = this._pluginStateMap.get(plugin);\n            const statefulCallback = param => {\n              const statefulParam = Object.assign(Object.assign({}, param), {\n                state\n              });\n              // TODO(philipwalton): not sure why `any` is needed. It seems like\n              // this should work with `as WorkboxPluginCallbackParam[C]`.\n              return plugin[name](statefulParam);\n            };\n            yield statefulCallback;\n          }\n        }\n      }\n      /**\n       * Adds a promise to the\n       * [extend lifetime promises]{@link https://w3c.github.io/ServiceWorker/#extendableevent-extend-lifetime-promises}\n       * of the event event associated with the request being handled (usually a\n       * `FetchEvent`).\n       *\n       * Note: you can await\n       * {@link workbox-strategies.StrategyHandler~doneWaiting}\n       * to know when all added promises have settled.\n       *\n       * @param {Promise} promise A promise to add to the extend lifetime promises\n       *     of the event that triggered the request.\n       */\n      waitUntil(promise) {\n        this._extendLifetimePromises.push(promise);\n        return promise;\n      }\n      /**\n       * Returns a promise that resolves once all promises passed to\n       * {@link workbox-strategies.StrategyHandler~waitUntil}\n       * have settled.\n       *\n       * Note: any work done after `doneWaiting()` settles should be manually\n       * passed to an event's `waitUntil()` method (not this handler's\n       * `waitUntil()` method), otherwise the service worker thread my be killed\n       * prior to your work completing.\n       */\n      async doneWaiting() {\n        let promise;\n        while (promise = this._extendLifetimePromises.shift()) {\n          await promise;\n        }\n      }\n      /**\n       * Stops running the strategy and immediately resolves any pending\n       * `waitUntil()` promises.\n       */\n      destroy() {\n        this._handlerDeferred.resolve(null);\n      }\n      /**\n       * This method will call cacheWillUpdate on the available plugins (or use\n       * status === 200) to determine if the Response is safe and valid to cache.\n       *\n       * @param {Request} options.request\n       * @param {Response} options.response\n       * @return {Promise<Response|undefined>}\n       *\n       * @private\n       */\n      async _ensureResponseSafeToCache(response) {\n        let responseToCache = response;\n        let pluginsUsed = false;\n        for (const callback of this.iterateCallbacks('cacheWillUpdate')) {\n          responseToCache = (await callback({\n            request: this.request,\n            response: responseToCache,\n            event: this.event\n          })) || undefined;\n          pluginsUsed = true;\n          if (!responseToCache) {\n            break;\n          }\n        }\n        if (!pluginsUsed) {\n          if (responseToCache && responseToCache.status !== 200) {\n            responseToCache = undefined;\n          }\n          {\n            if (responseToCache) {\n              if (responseToCache.status !== 200) {\n                if (responseToCache.status === 0) {\n                  logger.warn(`The response for '${this.request.url}' ` + `is an opaque response. The caching strategy that you're ` + `using will not cache opaque responses by default.`);\n                } else {\n                  logger.debug(`The response for '${this.request.url}' ` + `returned a status code of '${response.status}' and won't ` + `be cached as a result.`);\n                }\n              }\n            }\n          }\n        }\n        return responseToCache;\n      }\n    }\n\n    /*\n      Copyright 2020 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * An abstract base class that all other strategy classes must extend from:\n     *\n     * @memberof workbox-strategies\n     */\n    class Strategy {\n      /**\n       * Creates a new instance of the strategy and sets all documented option\n       * properties as public instance properties.\n       *\n       * Note: if a custom strategy class extends the base Strategy class and does\n       * not need more than these properties, it does not need to define its own\n       * constructor.\n       *\n       * @param {Object} [options]\n       * @param {string} [options.cacheName] Cache name to store and retrieve\n       * requests. Defaults to the cache names provided by\n       * {@link workbox-core.cacheNames}.\n       * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n       * to use in conjunction with this caching strategy.\n       * @param {Object} [options.fetchOptions] Values passed along to the\n       * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n       * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n       * `fetch()` requests made by this strategy.\n       * @param {Object} [options.matchOptions] The\n       * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n       * for any `cache.match()` or `cache.put()` calls made by this strategy.\n       */\n      constructor(options = {}) {\n        /**\n         * Cache name to store and retrieve\n         * requests. Defaults to the cache names provided by\n         * {@link workbox-core.cacheNames}.\n         *\n         * @type {string}\n         */\n        this.cacheName = cacheNames.getRuntimeName(options.cacheName);\n        /**\n         * The list\n         * [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n         * used by this strategy.\n         *\n         * @type {Array<Object>}\n         */\n        this.plugins = options.plugins || [];\n        /**\n         * Values passed along to the\n         * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}\n         * of all fetch() requests made by this strategy.\n         *\n         * @type {Object}\n         */\n        this.fetchOptions = options.fetchOptions;\n        /**\n         * The\n         * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n         * for any `cache.match()` or `cache.put()` calls made by this strategy.\n         *\n         * @type {Object}\n         */\n        this.matchOptions = options.matchOptions;\n      }\n      /**\n       * Perform a request strategy and returns a `Promise` that will resolve with\n       * a `Response`, invoking all relevant plugin callbacks.\n       *\n       * When a strategy instance is registered with a Workbox\n       * {@link workbox-routing.Route}, this method is automatically\n       * called when the route matches.\n       *\n       * Alternatively, this method can be used in a standalone `FetchEvent`\n       * listener by passing it to `event.respondWith()`.\n       *\n       * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\n       *     properties listed below.\n       * @param {Request|string} options.request A request to run this strategy for.\n       * @param {ExtendableEvent} options.event The event associated with the\n       *     request.\n       * @param {URL} [options.url]\n       * @param {*} [options.params]\n       */\n      handle(options) {\n        const [responseDone] = this.handleAll(options);\n        return responseDone;\n      }\n      /**\n       * Similar to {@link workbox-strategies.Strategy~handle}, but\n       * instead of just returning a `Promise` that resolves to a `Response` it\n       * it will return an tuple of `[response, done]` promises, where the former\n       * (`response`) is equivalent to what `handle()` returns, and the latter is a\n       * Promise that will resolve once any promises that were added to\n       * `event.waitUntil()` as part of performing the strategy have completed.\n       *\n       * You can await the `done` promise to ensure any extra work performed by\n       * the strategy (usually caching responses) completes successfully.\n       *\n       * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\n       *     properties listed below.\n       * @param {Request|string} options.request A request to run this strategy for.\n       * @param {ExtendableEvent} options.event The event associated with the\n       *     request.\n       * @param {URL} [options.url]\n       * @param {*} [options.params]\n       * @return {Array<Promise>} A tuple of [response, done]\n       *     promises that can be used to determine when the response resolves as\n       *     well as when the handler has completed all its work.\n       */\n      handleAll(options) {\n        // Allow for flexible options to be passed.\n        if (options instanceof FetchEvent) {\n          options = {\n            event: options,\n            request: options.request\n          };\n        }\n        const event = options.event;\n        const request = typeof options.request === 'string' ? new Request(options.request) : options.request;\n        const params = 'params' in options ? options.params : undefined;\n        const handler = new StrategyHandler(this, {\n          event,\n          request,\n          params\n        });\n        const responseDone = this._getResponse(handler, request, event);\n        const handlerDone = this._awaitComplete(responseDone, handler, request, event);\n        // Return an array of promises, suitable for use with Promise.all().\n        return [responseDone, handlerDone];\n      }\n      async _getResponse(handler, request, event) {\n        await handler.runCallbacks('handlerWillStart', {\n          event,\n          request\n        });\n        let response = undefined;\n        try {\n          response = await this._handle(request, handler);\n          // The \"official\" Strategy subclasses all throw this error automatically,\n          // but in case a third-party Strategy doesn't, ensure that we have a\n          // consistent failure when there's no response or an error response.\n          if (!response || response.type === 'error') {\n            throw new WorkboxError('no-response', {\n              url: request.url\n            });\n          }\n        } catch (error) {\n          if (error instanceof Error) {\n            for (const callback of handler.iterateCallbacks('handlerDidError')) {\n              response = await callback({\n                error,\n                event,\n                request\n              });\n              if (response) {\n                break;\n              }\n            }\n          }\n          if (!response) {\n            throw error;\n          } else {\n            logger.log(`While responding to '${getFriendlyURL(request.url)}', ` + `an ${error instanceof Error ? error.toString() : ''} error occurred. Using a fallback response provided by ` + `a handlerDidError plugin.`);\n          }\n        }\n        for (const callback of handler.iterateCallbacks('handlerWillRespond')) {\n          response = await callback({\n            event,\n            request,\n            response\n          });\n        }\n        return response;\n      }\n      async _awaitComplete(responseDone, handler, request, event) {\n        let response;\n        let error;\n        try {\n          response = await responseDone;\n        } catch (error) {\n          // Ignore errors, as response errors should be caught via the `response`\n          // promise above. The `done` promise will only throw for errors in\n          // promises passed to `handler.waitUntil()`.\n        }\n        try {\n          await handler.runCallbacks('handlerDidRespond', {\n            event,\n            request,\n            response\n          });\n          await handler.doneWaiting();\n        } catch (waitUntilError) {\n          if (waitUntilError instanceof Error) {\n            error = waitUntilError;\n          }\n        }\n        await handler.runCallbacks('handlerDidComplete', {\n          event,\n          request,\n          response,\n          error: error\n        });\n        handler.destroy();\n        if (error) {\n          throw error;\n        }\n      }\n    }\n    /**\n     * Classes extending the `Strategy` based class should implement this method,\n     * and leverage the {@link workbox-strategies.StrategyHandler}\n     * arg to perform all fetching and cache logic, which will ensure all relevant\n     * cache, cache options, fetch options and plugins are used (per the current\n     * strategy instance).\n     *\n     * @name _handle\n     * @instance\n     * @abstract\n     * @function\n     * @param {Request} request\n     * @param {workbox-strategies.StrategyHandler} handler\n     * @return {Promise<Response>}\n     *\n     * @memberof workbox-strategies.Strategy\n     */\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    const messages = {\n      strategyStart: (strategyName, request) => `Using ${strategyName} to respond to '${getFriendlyURL(request.url)}'`,\n      printFinalResponse: response => {\n        if (response) {\n          logger.groupCollapsed(`View the final response here.`);\n          logger.log(response || '[No response returned]');\n          logger.groupEnd();\n        }\n      }\n    };\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * An implementation of a [cache-first](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#cache-first-falling-back-to-network)\n     * request strategy.\n     *\n     * A cache first strategy is useful for assets that have been revisioned,\n     * such as URLs like `/styles/example.a8f5f1.css`, since they\n     * can be cached for long periods of time.\n     *\n     * If the network request fails, and there is no cache match, this will throw\n     * a `WorkboxError` exception.\n     *\n     * @extends workbox-strategies.Strategy\n     * @memberof workbox-strategies\n     */\n    class CacheFirst extends Strategy {\n      /**\n       * @private\n       * @param {Request|string} request A request to run this strategy for.\n       * @param {workbox-strategies.StrategyHandler} handler The event that\n       *     triggered the request.\n       * @return {Promise<Response>}\n       */\n      async _handle(request, handler) {\n        const logs = [];\n        {\n          finalAssertExports.isInstance(request, Request, {\n            moduleName: 'workbox-strategies',\n            className: this.constructor.name,\n            funcName: 'makeRequest',\n            paramName: 'request'\n          });\n        }\n        let response = await handler.cacheMatch(request);\n        let error = undefined;\n        if (!response) {\n          {\n            logs.push(`No response found in the '${this.cacheName}' cache. ` + `Will respond with a network request.`);\n          }\n          try {\n            response = await handler.fetchAndCachePut(request);\n          } catch (err) {\n            if (err instanceof Error) {\n              error = err;\n            }\n          }\n          {\n            if (response) {\n              logs.push(`Got response from network.`);\n            } else {\n              logs.push(`Unable to get a response from the network.`);\n            }\n          }\n        } else {\n          {\n            logs.push(`Found a cached response in the '${this.cacheName}' cache.`);\n          }\n        }\n        {\n          logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n          for (const log of logs) {\n            logger.log(log);\n          }\n          messages.printFinalResponse(response);\n          logger.groupEnd();\n        }\n        if (!response) {\n          throw new WorkboxError('no-response', {\n            url: request.url,\n            error\n          });\n        }\n        return response;\n      }\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    const cacheOkAndOpaquePlugin = {\n      /**\n       * Returns a valid response (to allow caching) if the status is 200 (OK) or\n       * 0 (opaque).\n       *\n       * @param {Object} options\n       * @param {Response} options.response\n       * @return {Response|null}\n       *\n       * @private\n       */\n      cacheWillUpdate: async ({\n        response\n      }) => {\n        if (response.status === 200 || response.status === 0) {\n          return response;\n        }\n        return null;\n      }\n    };\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * An implementation of a\n     * [network first](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#network-first-falling-back-to-cache)\n     * request strategy.\n     *\n     * By default, this strategy will cache responses with a 200 status code as\n     * well as [opaque responses](https://developer.chrome.com/docs/workbox/caching-resources-during-runtime/#opaque-responses).\n     * Opaque responses are are cross-origin requests where the response doesn't\n     * support [CORS](https://enable-cors.org/).\n     *\n     * If the network request fails, and there is no cache match, this will throw\n     * a `WorkboxError` exception.\n     *\n     * @extends workbox-strategies.Strategy\n     * @memberof workbox-strategies\n     */\n    class NetworkFirst extends Strategy {\n      /**\n       * @param {Object} [options]\n       * @param {string} [options.cacheName] Cache name to store and retrieve\n       * requests. Defaults to cache names provided by\n       * {@link workbox-core.cacheNames}.\n       * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n       * to use in conjunction with this caching strategy.\n       * @param {Object} [options.fetchOptions] Values passed along to the\n       * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n       * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n       * `fetch()` requests made by this strategy.\n       * @param {Object} [options.matchOptions] [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n       * @param {number} [options.networkTimeoutSeconds] If set, any network requests\n       * that fail to respond within the timeout will fallback to the cache.\n       *\n       * This option can be used to combat\n       * \"[lie-fi]{@link https://developers.google.com/web/fundamentals/performance/poor-connectivity/#lie-fi}\"\n       * scenarios.\n       */\n      constructor(options = {}) {\n        super(options);\n        // If this instance contains no plugins with a 'cacheWillUpdate' callback,\n        // prepend the `cacheOkAndOpaquePlugin` plugin to the plugins list.\n        if (!this.plugins.some(p => 'cacheWillUpdate' in p)) {\n          this.plugins.unshift(cacheOkAndOpaquePlugin);\n        }\n        this._networkTimeoutSeconds = options.networkTimeoutSeconds || 0;\n        {\n          if (this._networkTimeoutSeconds) {\n            finalAssertExports.isType(this._networkTimeoutSeconds, 'number', {\n              moduleName: 'workbox-strategies',\n              className: this.constructor.name,\n              funcName: 'constructor',\n              paramName: 'networkTimeoutSeconds'\n            });\n          }\n        }\n      }\n      /**\n       * @private\n       * @param {Request|string} request A request to run this strategy for.\n       * @param {workbox-strategies.StrategyHandler} handler The event that\n       *     triggered the request.\n       * @return {Promise<Response>}\n       */\n      async _handle(request, handler) {\n        const logs = [];\n        {\n          finalAssertExports.isInstance(request, Request, {\n            moduleName: 'workbox-strategies',\n            className: this.constructor.name,\n            funcName: 'handle',\n            paramName: 'makeRequest'\n          });\n        }\n        const promises = [];\n        let timeoutId;\n        if (this._networkTimeoutSeconds) {\n          const {\n            id,\n            promise\n          } = this._getTimeoutPromise({\n            request,\n            logs,\n            handler\n          });\n          timeoutId = id;\n          promises.push(promise);\n        }\n        const networkPromise = this._getNetworkPromise({\n          timeoutId,\n          request,\n          logs,\n          handler\n        });\n        promises.push(networkPromise);\n        const response = await handler.waitUntil((async () => {\n          // Promise.race() will resolve as soon as the first promise resolves.\n          return (await handler.waitUntil(Promise.race(promises))) || (\n          // If Promise.race() resolved with null, it might be due to a network\n          // timeout + a cache miss. If that were to happen, we'd rather wait until\n          // the networkPromise resolves instead of returning null.\n          // Note that it's fine to await an already-resolved promise, so we don't\n          // have to check to see if it's still \"in flight\".\n          await networkPromise);\n        })());\n        {\n          logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n          for (const log of logs) {\n            logger.log(log);\n          }\n          messages.printFinalResponse(response);\n          logger.groupEnd();\n        }\n        if (!response) {\n          throw new WorkboxError('no-response', {\n            url: request.url\n          });\n        }\n        return response;\n      }\n      /**\n       * @param {Object} options\n       * @param {Request} options.request\n       * @param {Array} options.logs A reference to the logs array\n       * @param {Event} options.event\n       * @return {Promise<Response>}\n       *\n       * @private\n       */\n      _getTimeoutPromise({\n        request,\n        logs,\n        handler\n      }) {\n        let timeoutId;\n        const timeoutPromise = new Promise(resolve => {\n          const onNetworkTimeout = async () => {\n            {\n              logs.push(`Timing out the network response at ` + `${this._networkTimeoutSeconds} seconds.`);\n            }\n            resolve(await handler.cacheMatch(request));\n          };\n          timeoutId = setTimeout(onNetworkTimeout, this._networkTimeoutSeconds * 1000);\n        });\n        return {\n          promise: timeoutPromise,\n          id: timeoutId\n        };\n      }\n      /**\n       * @param {Object} options\n       * @param {number|undefined} options.timeoutId\n       * @param {Request} options.request\n       * @param {Array} options.logs A reference to the logs Array.\n       * @param {Event} options.event\n       * @return {Promise<Response>}\n       *\n       * @private\n       */\n      async _getNetworkPromise({\n        timeoutId,\n        request,\n        logs,\n        handler\n      }) {\n        let error;\n        let response;\n        try {\n          response = await handler.fetchAndCachePut(request);\n        } catch (fetchError) {\n          if (fetchError instanceof Error) {\n            error = fetchError;\n          }\n        }\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n        {\n          if (response) {\n            logs.push(`Got response from network.`);\n          } else {\n            logs.push(`Unable to get a response from the network. Will respond ` + `with a cached response.`);\n          }\n        }\n        if (error || !response) {\n          response = await handler.cacheMatch(request);\n          {\n            if (response) {\n              logs.push(`Found a cached response in the '${this.cacheName}'` + ` cache.`);\n            } else {\n              logs.push(`No response found in the '${this.cacheName}' cache.`);\n            }\n          }\n        }\n        return response;\n      }\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Claim any currently available clients once the service worker\n     * becomes active. This is normally used in conjunction with `skipWaiting()`.\n     *\n     * @memberof workbox-core\n     */\n    function clientsClaim() {\n      self.addEventListener('activate', () => self.clients.claim());\n    }\n\n    /*\n      Copyright 2020 Google LLC\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * A utility method that makes it easier to use `event.waitUntil` with\n     * async functions and return the result.\n     *\n     * @param {ExtendableEvent} event\n     * @param {Function} asyncFn\n     * @return {Function}\n     * @private\n     */\n    function waitUntil(event, asyncFn) {\n      const returnPromise = asyncFn();\n      event.waitUntil(returnPromise);\n      return returnPromise;\n    }\n\n    // @ts-ignore\n    try {\n      self['workbox:precaching:7.2.0'] && _();\n    } catch (e) {}\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    // Name of the search parameter used to store revision info.\n    const REVISION_SEARCH_PARAM = '__WB_REVISION__';\n    /**\n     * Converts a manifest entry into a versioned URL suitable for precaching.\n     *\n     * @param {Object|string} entry\n     * @return {string} A URL with versioning info.\n     *\n     * @private\n     * @memberof workbox-precaching\n     */\n    function createCacheKey(entry) {\n      if (!entry) {\n        throw new WorkboxError('add-to-cache-list-unexpected-type', {\n          entry\n        });\n      }\n      // If a precache manifest entry is a string, it's assumed to be a versioned\n      // URL, like '/app.abcd1234.js'. Return as-is.\n      if (typeof entry === 'string') {\n        const urlObject = new URL(entry, location.href);\n        return {\n          cacheKey: urlObject.href,\n          url: urlObject.href\n        };\n      }\n      const {\n        revision,\n        url\n      } = entry;\n      if (!url) {\n        throw new WorkboxError('add-to-cache-list-unexpected-type', {\n          entry\n        });\n      }\n      // If there's just a URL and no revision, then it's also assumed to be a\n      // versioned URL.\n      if (!revision) {\n        const urlObject = new URL(url, location.href);\n        return {\n          cacheKey: urlObject.href,\n          url: urlObject.href\n        };\n      }\n      // Otherwise, construct a properly versioned URL using the custom Workbox\n      // search parameter along with the revision info.\n      const cacheKeyURL = new URL(url, location.href);\n      const originalURL = new URL(url, location.href);\n      cacheKeyURL.searchParams.set(REVISION_SEARCH_PARAM, revision);\n      return {\n        cacheKey: cacheKeyURL.href,\n        url: originalURL.href\n      };\n    }\n\n    /*\n      Copyright 2020 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * A plugin, designed to be used with PrecacheController, to determine the\n     * of assets that were updated (or not updated) during the install event.\n     *\n     * @private\n     */\n    class PrecacheInstallReportPlugin {\n      constructor() {\n        this.updatedURLs = [];\n        this.notUpdatedURLs = [];\n        this.handlerWillStart = async ({\n          request,\n          state\n        }) => {\n          // TODO: `state` should never be undefined...\n          if (state) {\n            state.originalRequest = request;\n          }\n        };\n        this.cachedResponseWillBeUsed = async ({\n          event,\n          state,\n          cachedResponse\n        }) => {\n          if (event.type === 'install') {\n            if (state && state.originalRequest && state.originalRequest instanceof Request) {\n              // TODO: `state` should never be undefined...\n              const url = state.originalRequest.url;\n              if (cachedResponse) {\n                this.notUpdatedURLs.push(url);\n              } else {\n                this.updatedURLs.push(url);\n              }\n            }\n          }\n          return cachedResponse;\n        };\n      }\n    }\n\n    /*\n      Copyright 2020 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * A plugin, designed to be used with PrecacheController, to translate URLs into\n     * the corresponding cache key, based on the current revision info.\n     *\n     * @private\n     */\n    class PrecacheCacheKeyPlugin {\n      constructor({\n        precacheController\n      }) {\n        this.cacheKeyWillBeUsed = async ({\n          request,\n          params\n        }) => {\n          // Params is type any, can't change right now.\n          /* eslint-disable */\n          const cacheKey = (params === null || params === void 0 ? void 0 : params.cacheKey) || this._precacheController.getCacheKeyForURL(request.url);\n          /* eslint-enable */\n          return cacheKey ? new Request(cacheKey, {\n            headers: request.headers\n          }) : request;\n        };\n        this._precacheController = precacheController;\n      }\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * @param {string} groupTitle\n     * @param {Array<string>} deletedURLs\n     *\n     * @private\n     */\n    const logGroup = (groupTitle, deletedURLs) => {\n      logger.groupCollapsed(groupTitle);\n      for (const url of deletedURLs) {\n        logger.log(url);\n      }\n      logger.groupEnd();\n    };\n    /**\n     * @param {Array<string>} deletedURLs\n     *\n     * @private\n     * @memberof workbox-precaching\n     */\n    function printCleanupDetails(deletedURLs) {\n      const deletionCount = deletedURLs.length;\n      if (deletionCount > 0) {\n        logger.groupCollapsed(`During precaching cleanup, ` + `${deletionCount} cached ` + `request${deletionCount === 1 ? ' was' : 's were'} deleted.`);\n        logGroup('Deleted Cache Requests', deletedURLs);\n        logger.groupEnd();\n      }\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * @param {string} groupTitle\n     * @param {Array<string>} urls\n     *\n     * @private\n     */\n    function _nestedGroup(groupTitle, urls) {\n      if (urls.length === 0) {\n        return;\n      }\n      logger.groupCollapsed(groupTitle);\n      for (const url of urls) {\n        logger.log(url);\n      }\n      logger.groupEnd();\n    }\n    /**\n     * @param {Array<string>} urlsToPrecache\n     * @param {Array<string>} urlsAlreadyPrecached\n     *\n     * @private\n     * @memberof workbox-precaching\n     */\n    function printInstallDetails(urlsToPrecache, urlsAlreadyPrecached) {\n      const precachedCount = urlsToPrecache.length;\n      const alreadyPrecachedCount = urlsAlreadyPrecached.length;\n      if (precachedCount || alreadyPrecachedCount) {\n        let message = `Precaching ${precachedCount} file${precachedCount === 1 ? '' : 's'}.`;\n        if (alreadyPrecachedCount > 0) {\n          message += ` ${alreadyPrecachedCount} ` + `file${alreadyPrecachedCount === 1 ? ' is' : 's are'} already cached.`;\n        }\n        logger.groupCollapsed(message);\n        _nestedGroup(`View newly precached URLs.`, urlsToPrecache);\n        _nestedGroup(`View previously precached URLs.`, urlsAlreadyPrecached);\n        logger.groupEnd();\n      }\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    let supportStatus;\n    /**\n     * A utility function that determines whether the current browser supports\n     * constructing a new `Response` from a `response.body` stream.\n     *\n     * @return {boolean} `true`, if the current browser can successfully\n     *     construct a `Response` from a `response.body` stream, `false` otherwise.\n     *\n     * @private\n     */\n    function canConstructResponseFromBodyStream() {\n      if (supportStatus === undefined) {\n        const testResponse = new Response('');\n        if ('body' in testResponse) {\n          try {\n            new Response(testResponse.body);\n            supportStatus = true;\n          } catch (error) {\n            supportStatus = false;\n          }\n        }\n        supportStatus = false;\n      }\n      return supportStatus;\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Allows developers to copy a response and modify its `headers`, `status`,\n     * or `statusText` values (the values settable via a\n     * [`ResponseInit`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Response/Response#Syntax}\n     * object in the constructor).\n     * To modify these values, pass a function as the second argument. That\n     * function will be invoked with a single object with the response properties\n     * `{headers, status, statusText}`. The return value of this function will\n     * be used as the `ResponseInit` for the new `Response`. To change the values\n     * either modify the passed parameter(s) and return it, or return a totally\n     * new object.\n     *\n     * This method is intentionally limited to same-origin responses, regardless of\n     * whether CORS was used or not.\n     *\n     * @param {Response} response\n     * @param {Function} modifier\n     * @memberof workbox-core\n     */\n    async function copyResponse(response, modifier) {\n      let origin = null;\n      // If response.url isn't set, assume it's cross-origin and keep origin null.\n      if (response.url) {\n        const responseURL = new URL(response.url);\n        origin = responseURL.origin;\n      }\n      if (origin !== self.location.origin) {\n        throw new WorkboxError('cross-origin-copy-response', {\n          origin\n        });\n      }\n      const clonedResponse = response.clone();\n      // Create a fresh `ResponseInit` object by cloning the headers.\n      const responseInit = {\n        headers: new Headers(clonedResponse.headers),\n        status: clonedResponse.status,\n        statusText: clonedResponse.statusText\n      };\n      // Apply any user modifications.\n      const modifiedResponseInit = modifier ? modifier(responseInit) : responseInit;\n      // Create the new response from the body stream and `ResponseInit`\n      // modifications. Note: not all browsers support the Response.body stream,\n      // so fall back to reading the entire body into memory as a blob.\n      const body = canConstructResponseFromBodyStream() ? clonedResponse.body : await clonedResponse.blob();\n      return new Response(body, modifiedResponseInit);\n    }\n\n    /*\n      Copyright 2020 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * A {@link workbox-strategies.Strategy} implementation\n     * specifically designed to work with\n     * {@link workbox-precaching.PrecacheController}\n     * to both cache and fetch precached assets.\n     *\n     * Note: an instance of this class is created automatically when creating a\n     * `PrecacheController`; it's generally not necessary to create this yourself.\n     *\n     * @extends workbox-strategies.Strategy\n     * @memberof workbox-precaching\n     */\n    class PrecacheStrategy extends Strategy {\n      /**\n       *\n       * @param {Object} [options]\n       * @param {string} [options.cacheName] Cache name to store and retrieve\n       * requests. Defaults to the cache names provided by\n       * {@link workbox-core.cacheNames}.\n       * @param {Array<Object>} [options.plugins] {@link https://developers.google.com/web/tools/workbox/guides/using-plugins|Plugins}\n       * to use in conjunction with this caching strategy.\n       * @param {Object} [options.fetchOptions] Values passed along to the\n       * {@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters|init}\n       * of all fetch() requests made by this strategy.\n       * @param {Object} [options.matchOptions] The\n       * {@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions|CacheQueryOptions}\n       * for any `cache.match()` or `cache.put()` calls made by this strategy.\n       * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to\n       * get the response from the network if there's a precache miss.\n       */\n      constructor(options = {}) {\n        options.cacheName = cacheNames.getPrecacheName(options.cacheName);\n        super(options);\n        this._fallbackToNetwork = options.fallbackToNetwork === false ? false : true;\n        // Redirected responses cannot be used to satisfy a navigation request, so\n        // any redirected response must be \"copied\" rather than cloned, so the new\n        // response doesn't contain the `redirected` flag. See:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=669363&desc=2#c1\n        this.plugins.push(PrecacheStrategy.copyRedirectedCacheableResponsesPlugin);\n      }\n      /**\n       * @private\n       * @param {Request|string} request A request to run this strategy for.\n       * @param {workbox-strategies.StrategyHandler} handler The event that\n       *     triggered the request.\n       * @return {Promise<Response>}\n       */\n      async _handle(request, handler) {\n        const response = await handler.cacheMatch(request);\n        if (response) {\n          return response;\n        }\n        // If this is an `install` event for an entry that isn't already cached,\n        // then populate the cache.\n        if (handler.event && handler.event.type === 'install') {\n          return await this._handleInstall(request, handler);\n        }\n        // Getting here means something went wrong. An entry that should have been\n        // precached wasn't found in the cache.\n        return await this._handleFetch(request, handler);\n      }\n      async _handleFetch(request, handler) {\n        let response;\n        const params = handler.params || {};\n        // Fall back to the network if we're configured to do so.\n        if (this._fallbackToNetwork) {\n          {\n            logger.warn(`The precached response for ` + `${getFriendlyURL(request.url)} in ${this.cacheName} was not ` + `found. Falling back to the network.`);\n          }\n          const integrityInManifest = params.integrity;\n          const integrityInRequest = request.integrity;\n          const noIntegrityConflict = !integrityInRequest || integrityInRequest === integrityInManifest;\n          // Do not add integrity if the original request is no-cors\n          // See https://github.com/GoogleChrome/workbox/issues/3096\n          response = await handler.fetch(new Request(request, {\n            integrity: request.mode !== 'no-cors' ? integrityInRequest || integrityInManifest : undefined\n          }));\n          // It's only \"safe\" to repair the cache if we're using SRI to guarantee\n          // that the response matches the precache manifest's expectations,\n          // and there's either a) no integrity property in the incoming request\n          // or b) there is an integrity, and it matches the precache manifest.\n          // See https://github.com/GoogleChrome/workbox/issues/2858\n          // Also if the original request users no-cors we don't use integrity.\n          // See https://github.com/GoogleChrome/workbox/issues/3096\n          if (integrityInManifest && noIntegrityConflict && request.mode !== 'no-cors') {\n            this._useDefaultCacheabilityPluginIfNeeded();\n            const wasCached = await handler.cachePut(request, response.clone());\n            {\n              if (wasCached) {\n                logger.log(`A response for ${getFriendlyURL(request.url)} ` + `was used to \"repair\" the precache.`);\n              }\n            }\n          }\n        } else {\n          // This shouldn't normally happen, but there are edge cases:\n          // https://github.com/GoogleChrome/workbox/issues/1441\n          throw new WorkboxError('missing-precache-entry', {\n            cacheName: this.cacheName,\n            url: request.url\n          });\n        }\n        {\n          const cacheKey = params.cacheKey || (await handler.getCacheKey(request, 'read'));\n          // Workbox is going to handle the route.\n          // print the routing details to the console.\n          logger.groupCollapsed(`Precaching is responding to: ` + getFriendlyURL(request.url));\n          logger.log(`Serving the precached url: ${getFriendlyURL(cacheKey instanceof Request ? cacheKey.url : cacheKey)}`);\n          logger.groupCollapsed(`View request details here.`);\n          logger.log(request);\n          logger.groupEnd();\n          logger.groupCollapsed(`View response details here.`);\n          logger.log(response);\n          logger.groupEnd();\n          logger.groupEnd();\n        }\n        return response;\n      }\n      async _handleInstall(request, handler) {\n        this._useDefaultCacheabilityPluginIfNeeded();\n        const response = await handler.fetch(request);\n        // Make sure we defer cachePut() until after we know the response\n        // should be cached; see https://github.com/GoogleChrome/workbox/issues/2737\n        const wasCached = await handler.cachePut(request, response.clone());\n        if (!wasCached) {\n          // Throwing here will lead to the `install` handler failing, which\n          // we want to do if *any* of the responses aren't safe to cache.\n          throw new WorkboxError('bad-precaching-response', {\n            url: request.url,\n            status: response.status\n          });\n        }\n        return response;\n      }\n      /**\n       * This method is complex, as there a number of things to account for:\n       *\n       * The `plugins` array can be set at construction, and/or it might be added to\n       * to at any time before the strategy is used.\n       *\n       * At the time the strategy is used (i.e. during an `install` event), there\n       * needs to be at least one plugin that implements `cacheWillUpdate` in the\n       * array, other than `copyRedirectedCacheableResponsesPlugin`.\n       *\n       * - If this method is called and there are no suitable `cacheWillUpdate`\n       * plugins, we need to add `defaultPrecacheCacheabilityPlugin`.\n       *\n       * - If this method is called and there is exactly one `cacheWillUpdate`, then\n       * we don't have to do anything (this might be a previously added\n       * `defaultPrecacheCacheabilityPlugin`, or it might be a custom plugin).\n       *\n       * - If this method is called and there is more than one `cacheWillUpdate`,\n       * then we need to check if one is `defaultPrecacheCacheabilityPlugin`. If so,\n       * we need to remove it. (This situation is unlikely, but it could happen if\n       * the strategy is used multiple times, the first without a `cacheWillUpdate`,\n       * and then later on after manually adding a custom `cacheWillUpdate`.)\n       *\n       * See https://github.com/GoogleChrome/workbox/issues/2737 for more context.\n       *\n       * @private\n       */\n      _useDefaultCacheabilityPluginIfNeeded() {\n        let defaultPluginIndex = null;\n        let cacheWillUpdatePluginCount = 0;\n        for (const [index, plugin] of this.plugins.entries()) {\n          // Ignore the copy redirected plugin when determining what to do.\n          if (plugin === PrecacheStrategy.copyRedirectedCacheableResponsesPlugin) {\n            continue;\n          }\n          // Save the default plugin's index, in case it needs to be removed.\n          if (plugin === PrecacheStrategy.defaultPrecacheCacheabilityPlugin) {\n            defaultPluginIndex = index;\n          }\n          if (plugin.cacheWillUpdate) {\n            cacheWillUpdatePluginCount++;\n          }\n        }\n        if (cacheWillUpdatePluginCount === 0) {\n          this.plugins.push(PrecacheStrategy.defaultPrecacheCacheabilityPlugin);\n        } else if (cacheWillUpdatePluginCount > 1 && defaultPluginIndex !== null) {\n          // Only remove the default plugin; multiple custom plugins are allowed.\n          this.plugins.splice(defaultPluginIndex, 1);\n        }\n        // Nothing needs to be done if cacheWillUpdatePluginCount is 1\n      }\n    }\n    PrecacheStrategy.defaultPrecacheCacheabilityPlugin = {\n      async cacheWillUpdate({\n        response\n      }) {\n        if (!response || response.status >= 400) {\n          return null;\n        }\n        return response;\n      }\n    };\n    PrecacheStrategy.copyRedirectedCacheableResponsesPlugin = {\n      async cacheWillUpdate({\n        response\n      }) {\n        return response.redirected ? await copyResponse(response) : response;\n      }\n    };\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Performs efficient precaching of assets.\n     *\n     * @memberof workbox-precaching\n     */\n    class PrecacheController {\n      /**\n       * Create a new PrecacheController.\n       *\n       * @param {Object} [options]\n       * @param {string} [options.cacheName] The cache to use for precaching.\n       * @param {string} [options.plugins] Plugins to use when precaching as well\n       * as responding to fetch events for precached assets.\n       * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to\n       * get the response from the network if there's a precache miss.\n       */\n      constructor({\n        cacheName,\n        plugins = [],\n        fallbackToNetwork = true\n      } = {}) {\n        this._urlsToCacheKeys = new Map();\n        this._urlsToCacheModes = new Map();\n        this._cacheKeysToIntegrities = new Map();\n        this._strategy = new PrecacheStrategy({\n          cacheName: cacheNames.getPrecacheName(cacheName),\n          plugins: [...plugins, new PrecacheCacheKeyPlugin({\n            precacheController: this\n          })],\n          fallbackToNetwork\n        });\n        // Bind the install and activate methods to the instance.\n        this.install = this.install.bind(this);\n        this.activate = this.activate.bind(this);\n      }\n      /**\n       * @type {workbox-precaching.PrecacheStrategy} The strategy created by this controller and\n       * used to cache assets and respond to fetch events.\n       */\n      get strategy() {\n        return this._strategy;\n      }\n      /**\n       * Adds items to the precache list, removing any duplicates and\n       * stores the files in the\n       * {@link workbox-core.cacheNames|\"precache cache\"} when the service\n       * worker installs.\n       *\n       * This method can be called multiple times.\n       *\n       * @param {Array<Object|string>} [entries=[]] Array of entries to precache.\n       */\n      precache(entries) {\n        this.addToCacheList(entries);\n        if (!this._installAndActiveListenersAdded) {\n          self.addEventListener('install', this.install);\n          self.addEventListener('activate', this.activate);\n          this._installAndActiveListenersAdded = true;\n        }\n      }\n      /**\n       * This method will add items to the precache list, removing duplicates\n       * and ensuring the information is valid.\n       *\n       * @param {Array<workbox-precaching.PrecacheController.PrecacheEntry|string>} entries\n       *     Array of entries to precache.\n       */\n      addToCacheList(entries) {\n        {\n          finalAssertExports.isArray(entries, {\n            moduleName: 'workbox-precaching',\n            className: 'PrecacheController',\n            funcName: 'addToCacheList',\n            paramName: 'entries'\n          });\n        }\n        const urlsToWarnAbout = [];\n        for (const entry of entries) {\n          // See https://github.com/GoogleChrome/workbox/issues/2259\n          if (typeof entry === 'string') {\n            urlsToWarnAbout.push(entry);\n          } else if (entry && entry.revision === undefined) {\n            urlsToWarnAbout.push(entry.url);\n          }\n          const {\n            cacheKey,\n            url\n          } = createCacheKey(entry);\n          const cacheMode = typeof entry !== 'string' && entry.revision ? 'reload' : 'default';\n          if (this._urlsToCacheKeys.has(url) && this._urlsToCacheKeys.get(url) !== cacheKey) {\n            throw new WorkboxError('add-to-cache-list-conflicting-entries', {\n              firstEntry: this._urlsToCacheKeys.get(url),\n              secondEntry: cacheKey\n            });\n          }\n          if (typeof entry !== 'string' && entry.integrity) {\n            if (this._cacheKeysToIntegrities.has(cacheKey) && this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {\n              throw new WorkboxError('add-to-cache-list-conflicting-integrities', {\n                url\n              });\n            }\n            this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);\n          }\n          this._urlsToCacheKeys.set(url, cacheKey);\n          this._urlsToCacheModes.set(url, cacheMode);\n          if (urlsToWarnAbout.length > 0) {\n            const warningMessage = `Workbox is precaching URLs without revision ` + `info: ${urlsToWarnAbout.join(', ')}\\nThis is generally NOT safe. ` + `Learn more at https://bit.ly/wb-precache`;\n            {\n              logger.warn(warningMessage);\n            }\n          }\n        }\n      }\n      /**\n       * Precaches new and updated assets. Call this method from the service worker\n       * install event.\n       *\n       * Note: this method calls `event.waitUntil()` for you, so you do not need\n       * to call it yourself in your event handlers.\n       *\n       * @param {ExtendableEvent} event\n       * @return {Promise<workbox-precaching.InstallResult>}\n       */\n      install(event) {\n        // waitUntil returns Promise<any>\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return waitUntil(event, async () => {\n          const installReportPlugin = new PrecacheInstallReportPlugin();\n          this.strategy.plugins.push(installReportPlugin);\n          // Cache entries one at a time.\n          // See https://github.com/GoogleChrome/workbox/issues/2528\n          for (const [url, cacheKey] of this._urlsToCacheKeys) {\n            const integrity = this._cacheKeysToIntegrities.get(cacheKey);\n            const cacheMode = this._urlsToCacheModes.get(url);\n            const request = new Request(url, {\n              integrity,\n              cache: cacheMode,\n              credentials: 'same-origin'\n            });\n            await Promise.all(this.strategy.handleAll({\n              params: {\n                cacheKey\n              },\n              request,\n              event\n            }));\n          }\n          const {\n            updatedURLs,\n            notUpdatedURLs\n          } = installReportPlugin;\n          {\n            printInstallDetails(updatedURLs, notUpdatedURLs);\n          }\n          return {\n            updatedURLs,\n            notUpdatedURLs\n          };\n        });\n      }\n      /**\n       * Deletes assets that are no longer present in the current precache manifest.\n       * Call this method from the service worker activate event.\n       *\n       * Note: this method calls `event.waitUntil()` for you, so you do not need\n       * to call it yourself in your event handlers.\n       *\n       * @param {ExtendableEvent} event\n       * @return {Promise<workbox-precaching.CleanupResult>}\n       */\n      activate(event) {\n        // waitUntil returns Promise<any>\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return waitUntil(event, async () => {\n          const cache = await self.caches.open(this.strategy.cacheName);\n          const currentlyCachedRequests = await cache.keys();\n          const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\n          const deletedURLs = [];\n          for (const request of currentlyCachedRequests) {\n            if (!expectedCacheKeys.has(request.url)) {\n              await cache.delete(request);\n              deletedURLs.push(request.url);\n            }\n          }\n          {\n            printCleanupDetails(deletedURLs);\n          }\n          return {\n            deletedURLs\n          };\n        });\n      }\n      /**\n       * Returns a mapping of a precached URL to the corresponding cache key, taking\n       * into account the revision information for the URL.\n       *\n       * @return {Map<string, string>} A URL to cache key mapping.\n       */\n      getURLsToCacheKeys() {\n        return this._urlsToCacheKeys;\n      }\n      /**\n       * Returns a list of all the URLs that have been precached by the current\n       * service worker.\n       *\n       * @return {Array<string>} The precached URLs.\n       */\n      getCachedURLs() {\n        return [...this._urlsToCacheKeys.keys()];\n      }\n      /**\n       * Returns the cache key used for storing a given URL. If that URL is\n       * unversioned, like `/index.html', then the cache key will be the original\n       * URL with a search parameter appended to it.\n       *\n       * @param {string} url A URL whose cache key you want to look up.\n       * @return {string} The versioned URL that corresponds to a cache key\n       * for the original URL, or undefined if that URL isn't precached.\n       */\n      getCacheKeyForURL(url) {\n        const urlObject = new URL(url, location.href);\n        return this._urlsToCacheKeys.get(urlObject.href);\n      }\n      /**\n       * @param {string} url A cache key whose SRI you want to look up.\n       * @return {string} The subresource integrity associated with the cache key,\n       * or undefined if it's not set.\n       */\n      getIntegrityForCacheKey(cacheKey) {\n        return this._cacheKeysToIntegrities.get(cacheKey);\n      }\n      /**\n       * This acts as a drop-in replacement for\n       * [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)\n       * with the following differences:\n       *\n       * - It knows what the name of the precache is, and only checks in that cache.\n       * - It allows you to pass in an \"original\" URL without versioning parameters,\n       * and it will automatically look up the correct cache key for the currently\n       * active revision of that URL.\n       *\n       * E.g., `matchPrecache('index.html')` will find the correct precached\n       * response for the currently active service worker, even if the actual cache\n       * key is `'/index.html?__WB_REVISION__=1234abcd'`.\n       *\n       * @param {string|Request} request The key (without revisioning parameters)\n       * to look up in the precache.\n       * @return {Promise<Response|undefined>}\n       */\n      async matchPrecache(request) {\n        const url = request instanceof Request ? request.url : request;\n        const cacheKey = this.getCacheKeyForURL(url);\n        if (cacheKey) {\n          const cache = await self.caches.open(this.strategy.cacheName);\n          return cache.match(cacheKey);\n        }\n        return undefined;\n      }\n      /**\n       * Returns a function that looks up `url` in the precache (taking into\n       * account revision information), and returns the corresponding `Response`.\n       *\n       * @param {string} url The precached URL which will be used to lookup the\n       * `Response`.\n       * @return {workbox-routing~handlerCallback}\n       */\n      createHandlerBoundToURL(url) {\n        const cacheKey = this.getCacheKeyForURL(url);\n        if (!cacheKey) {\n          throw new WorkboxError('non-precached-url', {\n            url\n          });\n        }\n        return options => {\n          options.request = new Request(url);\n          options.params = Object.assign({\n            cacheKey\n          }, options.params);\n          return this.strategy.handle(options);\n        };\n      }\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    let precacheController;\n    /**\n     * @return {PrecacheController}\n     * @private\n     */\n    const getOrCreatePrecacheController = () => {\n      if (!precacheController) {\n        precacheController = new PrecacheController();\n      }\n      return precacheController;\n    };\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Removes any URL search parameters that should be ignored.\n     *\n     * @param {URL} urlObject The original URL.\n     * @param {Array<RegExp>} ignoreURLParametersMatching RegExps to test against\n     * each search parameter name. Matches mean that the search parameter should be\n     * ignored.\n     * @return {URL} The URL with any ignored search parameters removed.\n     *\n     * @private\n     * @memberof workbox-precaching\n     */\n    function removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching = []) {\n      // Convert the iterable into an array at the start of the loop to make sure\n      // deletion doesn't mess up iteration.\n      for (const paramName of [...urlObject.searchParams.keys()]) {\n        if (ignoreURLParametersMatching.some(regExp => regExp.test(paramName))) {\n          urlObject.searchParams.delete(paramName);\n        }\n      }\n      return urlObject;\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Generator function that yields possible variations on the original URL to\n     * check, one at a time.\n     *\n     * @param {string} url\n     * @param {Object} options\n     *\n     * @private\n     * @memberof workbox-precaching\n     */\n    function* generateURLVariations(url, {\n      ignoreURLParametersMatching = [/^utm_/, /^fbclid$/],\n      directoryIndex = 'index.html',\n      cleanURLs = true,\n      urlManipulation\n    } = {}) {\n      const urlObject = new URL(url, location.href);\n      urlObject.hash = '';\n      yield urlObject.href;\n      const urlWithoutIgnoredParams = removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching);\n      yield urlWithoutIgnoredParams.href;\n      if (directoryIndex && urlWithoutIgnoredParams.pathname.endsWith('/')) {\n        const directoryURL = new URL(urlWithoutIgnoredParams.href);\n        directoryURL.pathname += directoryIndex;\n        yield directoryURL.href;\n      }\n      if (cleanURLs) {\n        const cleanURL = new URL(urlWithoutIgnoredParams.href);\n        cleanURL.pathname += '.html';\n        yield cleanURL.href;\n      }\n      if (urlManipulation) {\n        const additionalURLs = urlManipulation({\n          url: urlObject\n        });\n        for (const urlToAttempt of additionalURLs) {\n          yield urlToAttempt.href;\n        }\n      }\n    }\n\n    /*\n      Copyright 2020 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * A subclass of {@link workbox-routing.Route} that takes a\n     * {@link workbox-precaching.PrecacheController}\n     * instance and uses it to match incoming requests and handle fetching\n     * responses from the precache.\n     *\n     * @memberof workbox-precaching\n     * @extends workbox-routing.Route\n     */\n    class PrecacheRoute extends Route {\n      /**\n       * @param {PrecacheController} precacheController A `PrecacheController`\n       * instance used to both match requests and respond to fetch events.\n       * @param {Object} [options] Options to control how requests are matched\n       * against the list of precached URLs.\n       * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will\n       * check cache entries for a URLs ending with '/' to see if there is a hit when\n       * appending the `directoryIndex` value.\n       * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/, /^fbclid$/]] An\n       * array of regex's to remove search params when looking for a cache match.\n       * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will\n       * check the cache for the URL with a `.html` added to the end of the end.\n       * @param {workbox-precaching~urlManipulation} [options.urlManipulation]\n       * This is a function that should take a URL and return an array of\n       * alternative URLs that should be checked for precache matches.\n       */\n      constructor(precacheController, options) {\n        const match = ({\n          request\n        }) => {\n          const urlsToCacheKeys = precacheController.getURLsToCacheKeys();\n          for (const possibleURL of generateURLVariations(request.url, options)) {\n            const cacheKey = urlsToCacheKeys.get(possibleURL);\n            if (cacheKey) {\n              const integrity = precacheController.getIntegrityForCacheKey(cacheKey);\n              return {\n                cacheKey,\n                integrity\n              };\n            }\n          }\n          {\n            logger.debug(`Precaching did not find a match for ` + getFriendlyURL(request.url));\n          }\n          return;\n        };\n        super(match, precacheController.strategy);\n      }\n    }\n\n    /*\n      Copyright 2019 Google LLC\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Add a `fetch` listener to the service worker that will\n     * respond to\n     * [network requests]{@link https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Custom_responses_to_requests}\n     * with precached assets.\n     *\n     * Requests for assets that aren't precached, the `FetchEvent` will not be\n     * responded to, allowing the event to fall through to other `fetch` event\n     * listeners.\n     *\n     * @param {Object} [options] See the {@link workbox-precaching.PrecacheRoute}\n     * options.\n     *\n     * @memberof workbox-precaching\n     */\n    function addRoute(options) {\n      const precacheController = getOrCreatePrecacheController();\n      const precacheRoute = new PrecacheRoute(precacheController, options);\n      registerRoute(precacheRoute);\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Adds items to the precache list, removing any duplicates and\n     * stores the files in the\n     * {@link workbox-core.cacheNames|\"precache cache\"} when the service\n     * worker installs.\n     *\n     * This method can be called multiple times.\n     *\n     * Please note: This method **will not** serve any of the cached files for you.\n     * It only precaches files. To respond to a network request you call\n     * {@link workbox-precaching.addRoute}.\n     *\n     * If you have a single array of files to precache, you can just call\n     * {@link workbox-precaching.precacheAndRoute}.\n     *\n     * @param {Array<Object|string>} [entries=[]] Array of entries to precache.\n     *\n     * @memberof workbox-precaching\n     */\n    function precache(entries) {\n      const precacheController = getOrCreatePrecacheController();\n      precacheController.precache(entries);\n    }\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * This method will add entries to the precache list and add a route to\n     * respond to fetch events.\n     *\n     * This is a convenience method that will call\n     * {@link workbox-precaching.precache} and\n     * {@link workbox-precaching.addRoute} in a single call.\n     *\n     * @param {Array<Object|string>} entries Array of entries to precache.\n     * @param {Object} [options] See the\n     * {@link workbox-precaching.PrecacheRoute} options.\n     *\n     * @memberof workbox-precaching\n     */\n    function precacheAndRoute(entries, options) {\n      precache(entries);\n      addRoute(options);\n    }\n\n    /*\n      Copyright 2018 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    const SUBSTRING_TO_FIND = '-precache-';\n    /**\n     * Cleans up incompatible precaches that were created by older versions of\n     * Workbox, by a service worker registered under the current scope.\n     *\n     * This is meant to be called as part of the `activate` event.\n     *\n     * This should be safe to use as long as you don't include `substringToFind`\n     * (defaulting to `-precache-`) in your non-precache cache names.\n     *\n     * @param {string} currentPrecacheName The cache name currently in use for\n     * precaching. This cache won't be deleted.\n     * @param {string} [substringToFind='-precache-'] Cache names which include this\n     * substring will be deleted (excluding `currentPrecacheName`).\n     * @return {Array<string>} A list of all the cache names that were deleted.\n     *\n     * @private\n     * @memberof workbox-precaching\n     */\n    const deleteOutdatedCaches = async (currentPrecacheName, substringToFind = SUBSTRING_TO_FIND) => {\n      const cacheNames = await self.caches.keys();\n      const cacheNamesToDelete = cacheNames.filter(cacheName => {\n        return cacheName.includes(substringToFind) && cacheName.includes(self.registration.scope) && cacheName !== currentPrecacheName;\n      });\n      await Promise.all(cacheNamesToDelete.map(cacheName => self.caches.delete(cacheName)));\n      return cacheNamesToDelete;\n    };\n\n    /*\n      Copyright 2019 Google LLC\n\n      Use of this source code is governed by an MIT-style\n      license that can be found in the LICENSE file or at\n      https://opensource.org/licenses/MIT.\n    */\n    /**\n     * Adds an `activate` event listener which will clean up incompatible\n     * precaches that were created by older versions of Workbox.\n     *\n     * @memberof workbox-precaching\n     */\n    function cleanupOutdatedCaches() {\n      // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n      self.addEventListener('activate', event => {\n        const cacheName = cacheNames.getPrecacheName();\n        event.waitUntil(deleteOutdatedCaches(cacheName).then(cachesDeleted => {\n          {\n            if (cachesDeleted.length > 0) {\n              logger.log(`The following out-of-date precaches were cleaned up ` + `automatically:`, cachesDeleted);\n            }\n          }\n        }));\n      });\n    }\n\n    exports.CacheFirst = CacheFirst;\n    exports.CacheableResponsePlugin = CacheableResponsePlugin;\n    exports.ExpirationPlugin = ExpirationPlugin;\n    exports.NetworkFirst = NetworkFirst;\n    exports.cleanupOutdatedCaches = cleanupOutdatedCaches;\n    exports.clientsClaim = clientsClaim;\n    exports.precacheAndRoute = precacheAndRoute;\n    exports.registerRoute = registerRoute;\n\n}));\n//# sourceMappingURL=workbox-9be7f7ba.js.map\n"]}